!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.Open3d=e():t.Open3d=e()}(this,(()=>(()=>{"use strict";var t={387:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Intersection=void 0;const n=r(582),i=r(653),s=r(561),o=r(614),a=r(35);class l{constructor(){throw new Error("Cannot initialize an intersection instance.")}static LineLine(t,e,r=!1,n=i.Open3d.EPSILON){if(!t.IsValid||!e.IsValid)return null;const o=t.From,l=t.To,u=e.From,h=e.To,c=o.SubtractPoint(u),d=h.SubtractPoint(u),P=l.SubtractPoint(o),m=c.X*d.X+c.Y*d.Y+c.Z*d.Z,f=d.X*P.X+d.Y*P.Y+d.Z*P.Z,p=c.X*P.X+c.Y*P.Y+c.Z*P.Z,Y=d.X*d.X+d.Y*d.Y+d.Z*d.Z,Z=(P.X*P.X+P.Y*P.Y+P.Z*P.Z)*Y-f*f;if(s.Open3dMath.EpsilonEquals(Z,0))return null;const X=(m*f-p*Y)/Z,O=(m+f*X)/Y,A=new a.Point3d(o.X+X*P.X,o.Y+X*P.Y,o.Z+X*P.Z),g=new a.Point3d(u.X+O*d.X,u.Y+O*d.Y,u.Z+O*d.Z);if(A.DistanceTo(g)>n)return null;const M=A.AddPoint(g).Divide(2);if(!r)return M;const T=t.ClosestParameter(M,!1),w=e.ClosestParameter(M,!1);return T>=0&&T<=1&&w>=0&&w<=1?M:null}static LinePlane(t,e,r=!1){const n=t.From.SubtractPoint(e.Origin).DotProduct(e.Normal),i=t.UnitDirection.DotProduct(e.Normal);if(s.Open3dMath.EpsilonEquals(i,0))return null;const o=-n/i;return r&&(o<0||o>t.Length)?null:t.From.Add(t.UnitDirection.Multiply(o))}static PlanePlane(t,e){if(t.Normal.IsParallelTo(e.Normal))return null;const r=e.Normal.CrossProduct(t.Normal),i=t.Origin.AddPoint(e.Origin).Multiply(.5),s=o.Plane.CreateFromNormal(i,r),a=l.PlanePlanePlane(t,e,s);return null==a?null:new n.Line(a,a.Add(s.Normal))}static PlanePlanePlane(t,e,r){const n=t.Equation,i=e.Equation,o=r.Equation,l=[n[0],n[1],n[2],i[0],i[1],i[2],o[0],o[1],o[2]],u=[-n[3],-i[3],-o[3]],[h,c,d,P,m,f,p,Y,Z]=l,X=h*(m*Z-f*Y)-c*(P*Z-f*p)+d*(P*Y-m*p);if(s.Open3dMath.EpsilonEquals(X,0))return null;const O=1/X,A=O*(m*Z-f*Y)*u[0]+O*(d*Y-c*Z)*u[1]+O*(c*f-d*m)*u[2],g=O*(f*p-P*Z)*u[0]+O*(h*Z-d*p)*u[1]+O*(d*P-h*f)*u[2],M=O*(P*Y-m*p)*u[0]+O*(c*p-h*Y)*u[1]+O*(h*m-c*P)*u[2];return new a.Point3d(A,g,M)}}e.Intersection=l},582:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Line=void 0;const n=r(653),i=r(561);class s{constructor(t,e){this.From=t,this.To=e}get IsValid(){return!this.From.Equals(this.To)}get Direction(){if(!this.IsValid)throw new Error("Cannot get direction of an invalid line.");return this.To.SubtractPoint(this.From)}get UnitDirection(){return this.Direction.Unitize()}get Length(){return this.To.DistanceTo(this.From)}set Length(t){let e=this.UnitDirection;t<0&&(e=e.Reverse()),this.To=this.From.Add(e.Multiply(Math.abs(t)))}Clone(){return new s(this.From,this.To)}PointAt(t){if(!this.IsValid)throw new Error("Cannot evaluate an invalid line.");return this.Direction.Multiply(t).AddToPoint(this.From)}PointAtLength(t){if(!this.IsValid)throw new Error("Cannot evaluate an invalid line.");return this.UnitDirection.Multiply(t).AddToPoint(this.From)}ClosestParameter(t,e=!1){if(!this.IsValid)throw new Error("Invalid line does not have a closest point.");const r=t.SubtractPoint(this.From),n=this.To.SubtractPoint(this.From),s=n.DotProduct(n);let o=n.DotProduct(r)/s;return e&&(o=i.Open3dMath.Clamp(o,0,1)),o}ClosestPoint(t,e=!1){const r=this.ClosestParameter(t,e);return this.PointAt(r)}DistanceTo(t,e=!1){return this.ClosestPoint(t,e).DistanceTo(t)}Equals(t){return this.From.Equals(t.From)&&this.To.Equals(t.To)}IsPointOn(t,e=!1,r=n.Open3d.EPSILON){return this.DistanceTo(t,e)<=r}Extend(t,e){if(!this.IsValid)throw new Error("Cannot extend an invalid line.");const r=this.UnitDirection.Multiply(-t).AddToPoint(this.From),n=this.UnitDirection.Multiply(e).AddToPoint(this.To);return new s(r,n)}Flip(){return new s(this.To,this.From)}Transform(t){const e=this.From.Transform(t),r=this.To.Transform(t);return new s(e,r)}}e.Line=s},462:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Point3dList=e.List=void 0;class r{constructor(t){this.items=void 0===t?[]:t}Get(t){return this.items[t]}Set(t,e){this.items[t]=e}get Count(){return this.items.length}get First(){return this.items[0]}set First(t){this.items[0]=t}get Last(){return this.items[this.Count-1]}set Last(t){this.items[this.Count-1]=t}Clear(){this.items.length=0}Add(t){this.items.push(t)}AddRange(t){this.items.push(...t)}Contains(t,e){return this.items.includes(t,e)}Exists(t){return this.items.some(t)}Find(t){return this.items.find(t)}FindIndex(t){return this.items.findIndex(t)}FindAll(t){return this.items.filter(t)}ForEach(t){this.items.forEach(t)}Insert(t,e){this.items.splice(t,0,e)}InsertRange(t,e){this.items.splice(t,0,...e)}get NullOrUndefinedCount(){return this.items.filter((t=>null==t)).length}Reduce(t){return this.items.reduce(t)}Pop(){return this.items.pop()}Shift(){return this.items.shift()}Filter(t){return this.items.filter(t)}Map(t){return this.items.map(t)}Remove(t){const e=this.items.indexOf(t);e>-1&&this.items.splice(e,1)}RemoveBy(t){const e=this.Find(t);e&&this.Remove(e)}RemoveAll(t){this.items.filter(t).forEach((t=>this.Remove(t)))}Sort(t){this.items.sort(t)}Reverse(){return this.items.reverse()}}e.List=r,e.Point3dList=class extends r{}},653:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Open3d=void 0,function(t){let e;!function(t){t[t.Parallel=1]="Parallel",t[t.NotParallel=0]="NotParallel",t[t.AntiParallel=-1]="AntiParallel"}(e=t.ParallelIndicator||(t.ParallelIndicator={})),t.EPSILON=1e-6,t.ANGLE_EPSILON=.001}(e.Open3d||(e.Open3d={}))},561:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Open3dMath=void 0;const n=r(653);class i{static Clamp(t,e,r){if(e>r){const t=e;e=r,r=t}return Math.min(Math.max(t,e),r)}static ToDegrees(t){return 180*t/Math.PI}static ToRadians(t){return t*Math.PI/180}}e.Open3dMath=i,i.EpsilonEquals=(t,e,r=n.Open3d.EPSILON)=>Math.abs(t-e)<r},614:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Plane=void 0;const n=r(582),i=r(226),s=r(35),o=r(653);class a{constructor(t,e,r){if(e.IsTiny()||r.IsTiny())throw new Error("The input axis is not valid.");if(e.IsParallelTo(r))throw new Error("XAxis and YAxis should not be parallel.");e=e.Unitize(),r=r.Unitize();const n=e.CrossProduct(r).Unitize();r=n.CrossProduct(e).Unitize(),this.Origin=t,this.XAxis=e,this.YAxis=r,this.ZAxis=n}get Normal(){return this.ZAxis.Unitize()}get XAxisLine(){return new n.Line(this.Origin,this.Origin.Add(this.XAxis))}get YAxisLine(){return new n.Line(this.Origin,this.Origin.Add(this.YAxis))}get ZAxisLine(){return new n.Line(this.Origin,this.Origin.Add(this.ZAxis))}get Equation(){const{X:t,Y:e,Z:r}=this.Normal;return[t,e,r,-t*this.Origin.X-e*this.Origin.Y-r*this.Origin.Z]}static get PlaneXY(){return new a(s.Point3d.Origin,i.Vector3d.XAxis,i.Vector3d.YAxis)}static get PlaneZX(){return new a(s.Point3d.Origin,i.Vector3d.ZAxis,i.Vector3d.XAxis)}static get PlaneYZ(){return new a(s.Point3d.Origin,i.Vector3d.YAxis,i.Vector3d.ZAxis)}PointAt(t,e){return this.Origin.Add(this.XAxis.Multiply(t)).Add(this.YAxis.Multiply(e))}ClosestParameter(t){return[this.XAxisLine.ClosestParameter(t),this.YAxisLine.ClosestParameter(t)]}ClosestPoint(t){return this.PointAt(...this.ClosestParameter(t))}DistanceTo(t){const e=t.SubtractPoint(this.Origin),r=t.DistanceTo(this.ClosestPoint(t));return e.DotProduct(this.ZAxis)>0?r:-r}Clone(){return new a(this.Origin,this.XAxis,this.YAxis)}Flip(){return new a(this.Origin,this.YAxis,this.XAxis)}IsPointCoplanar(t,e=o.Open3d.EPSILON){return this.ClosestPoint(t).DistanceTo(t)<e}IsLineCoplanar(t,e=o.Open3d.EPSILON){return this.IsPointCoplanar(t.From,e)&&this.IsPointCoplanar(t.To,e)}static CreateFromNormal(t,e){const r=e.Unitize(),n=e.GetPerpendicularVector(),i=r.CrossProduct(n).Unitize();return new a(t,n,i)}static CreateFromFrame(t,e,r){return new a(t,e,r)}static CreateFrom3Points(t,e,r){const n=e.SubtractPoint(t),i=r.SubtractPoint(t),s=n.CrossProduct(i).CrossProduct(n);return new a(t,n,s)}Transform(t){const e=this.Origin.Transform(t),r=this.XAxis.Transform(t),n=this.YAxis.Transform(t);return new a(e,r,n)}}e.Plane=a},35:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Point3d=void 0;const n=r(561),i=r(226);class s{constructor(t,e,r){this.X=t,this.Y=e,this.Z=r}static CreateFromVector(t){return new s(t.X,t.Y,t.Z)}static CreateFromPoint3d(t){return new s(t.X,t.Y,t.Z)}static get Origin(){return new s(0,0,0)}static Add(t,e){return new s(t.X+e.X,t.Y+e.Y,t.Z+e.Z)}static AddPoint(t,e){return new s(t.X+e.X,t.Y+e.Y,t.Z+e.Z)}Add(t){return s.Add(this,t)}AddPoint(t){return s.AddPoint(this,t)}static Subtract(t,e){return new s(t.X-e.X,t.Y-e.Y,t.Z-e.Z)}static SubtractPoint(t,e){return new i.Vector3d(t.X-e.X,t.Y-e.Y,t.Z-e.Z)}Subtract(t){return s.Subtract(this,t)}SubtractPoint(t){return s.SubtractPoint(this,t)}static Multiply(t,e){return new s(t.X*e,t.Y*e,t.Z*e)}Multiply(t){return s.Multiply(this,t)}static Divide(t,e){if(0===e)throw new Error("Division by zero");const r=1/e;return new s(t.X*r,t.Y*r,t.Z*r)}Divide(t){return s.Divide(this,t)}static Interpolate(t,e,r){return new s(t.X+(e.X-t.X)*r,t.Y+(e.Y-t.Y)*r,t.Z+(e.Z-t.Z)*r)}static Distance(t,e){return Math.hypot(t.X-e.X,t.Y-e.Y,t.Z-e.Z)}DistanceTo(t){return s.Distance(this,t)}static Equals(t,e){return n.Open3dMath.EpsilonEquals(t.X,e.X)&&n.Open3dMath.EpsilonEquals(t.Y,e.Y)&&n.Open3dMath.EpsilonEquals(t.Z,e.Z)}Equals(t){return s.Equals(this,t)}Transform(t){let e,r,n;const i=t.M;return e=i[0]*this.X+i[1]*this.Y+i[2]*this.Z+i[3],r=i[4]*this.X+i[5]*this.Y+i[6]*this.Z+i[7],n=i[8]*this.X+i[9]*this.Y+i[10]*this.Z+i[11],new s(e,r,n)}toString(){return`Point3d [${this.X}, ${this.Y}, ${this.Z}]`}}e.Point3d=s},465:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Polyline=void 0;const n=r(582),i=r(462),s=r(653),o=r(614),a=r(35),l=r(950),u=r(226);class h extends i.Point3dList{constructor(t){super(t)}get CenterPoint(){const t=this.Count;if(0===t)return a.Point3d.Origin;if(1===t)return this.Get(0);let e=a.Point3d.Origin,r=0;for(let n=0;n<t-1;n++){let t=this.Get(n),i=this.Get(n+1),s=t.DistanceTo(i);e=e.AddPoint(a.Point3d.AddPoint(t,i).Multiply(.5*s)),r+=s}return e=e.Divide(r),e}get IsValid(){if(this.Count<2)return!1;for(let t=1;t<this.Count;t++)if(this.Get(t).Equals(this.Get(t-1)))return!1;return!(this.Count<4&&this.IsClosed)}get SegmentCount(){return Math.max(0,this.Count-1)}get IsClosed(){return this.Count>2&&this.First.Equals(this.Last)}get Length(){if(this.Count<2)return 0;let t=0;for(let e=0;e<this.Count-1;e++)t+=this.Get(e).DistanceTo(this.Get(e+1));return t}IsClosedWithinTolerance(t){return!(this.Count<=2)&&this.First.DistanceTo(this.Last)<=t}PointAt(t){const e=this.Count;if(e<1)return a.Point3d.Origin;if(1==e)return this.First;const r=Math.floor(t);if(r<0)return this.Get(0);if(r>=e-1)return this.Get(e-1);if((t-=r)<=0)return this.Get(r);if(t>=1)return this.Get(r+1);const n=this.Get(r),i=this.Get(r+1);let s=1-t;return new a.Point3d(n.X==i.X?n.X:s*n.X+t*i.X,n.Y==i.Y?n.Y:s*n.Y+t*i.Y,n.Z==i.Z?n.Z:s*n.Z+t*i.Z)}SegmentAt(t){return t<0||t>=this.Count-1?null:(t=Math.floor(t),new n.Line(this.Get(t),this.Get(t+1)))}TangentAt(t){const e=this.Count;if(e<2)return u.Vector3d.Zero;let r=Math.floor(t);return r<0?r=0:r>=e-1&&(r=e-2),this.Get(r+1).SubtractPoint(this.Get(r)).Unitize()}Trim(t,e){let r=this.Count-1,n=Math.floor(t),i=Math.floor(e),s=t-n,o=e-i;s<0&&(s=0),s>=1&&(n++,s=0),o<0&&(o=0),o>=1&&(i++,o=0),n<0&&(n=0,s=0),n>=r&&(n=r,s=0),i<0&&(i=0,o=0),i>=r&&(i=r,o=0);const a=h.CreateFromPoints([this.PointAt(t)]);for(let t=n+1;t<=i;t++)a.Add(this.Get(t));return o>0&&a.Add(this.PointAt(e)),a}ClosestPoint(t){const e=this.ClosestParameter(t);return this.PointAt(e)}ClosestParameter(t){const e=this.Count;if(e<2)return 0;let r=0,i=0,s=Number.MAX_VALUE;for(let o=0;o<e-1;o++){const e=new n.Line(this.Get(o),this.Get(o+1));let a,l;e.Direction.IsTiny()?(l=0,a=this.Get(o).DistanceTo(t)):(l=e.ClosestParameter(t),l<=0?l=0:l>1&&(l=1),a=e.PointAt(l).DistanceTo(t)),a<s&&(s=a,i=l,r=o)}return r+i}GetSegments(){if(this.Count<2)return[];const t=[];for(let e=0;e<this.Count-1;e++)t.push(new n.Line(this.Get(e),this.Get(e+1)));return t}DeleteShortSegments(t=s.Open3d.EPSILON){const e=this.Count;if(e<3)return h.CreateFromPoints(this.items);const r=new Array(e);r[0]=!0,r[e-1]=!0;let n=0;for(let i=1;i<e-1;i++)this.Get(i).DistanceTo(this.Get(n))<=t?r[i]=!1:(n=i,r[i]=!0);for(let n=e-2;n>0;n--)if(r[n]){if(!(this.Get(n).DistanceTo(this.Get(e-1))<=t))break;r[n]=!1}const i=new Array(e);let o=0;for(let t=0;t<e;t++)r[t]&&(i[o]=this.Get(t),o++);return h.CreateFromPoints(i)}Smooth(t){const e=this.Count;if(e<3)return null;let r=e-1;t*=.5;const n=new Array(e);this.IsClosed?(n[0]=h.Smooth(this.Get(r-1),this.Get(0),this.Get(1),t),n[r]=n[0]):(n[0]=this.Get(0),n[r]=this.Get(r));for(let e=1;e<r;e++)n[e]=h.Smooth(this.Get(e-1),this.Get(e),this.Get(e+1),t);return h.CreateFromPoints(n)}IsPlanar(t=s.Open3d.EPSILON){const e=this.Count;if(e<3)return!1;const r=o.Plane.CreateFrom3Points(this.Get(0),this.Get(1),this.Get(2));for(let n=3;n<e;n++)if(!r.IsPointCoplanar(this.Get(n),t))return!1;return!0}TryGetPlane(t=s.Open3d.EPSILON){return this.IsPlanar(t)?o.Plane.CreateFrom3Points(this.Get(0),this.Get(1),this.Get(2)):null}TryGetArea(t=s.Open3d.EPSILON){if(this.IsPlanar()&&this.IsClosed){const e=this.TryGetPlane(t),r=this.Transform(l.Transform.PlaneToPlane(e,o.Plane.PlaneXY));return Math.abs(h.SignedPolygonArea(r))}return null}IsPointOn(t,e=s.Open3d.EPSILON){const r=this.Count;if(r<2)return!1;for(let i=0;i<r-1;i++)if(new n.Line(this.Get(i),this.Get(i+1)).IsPointOn(t,!0,e))return!0;return!1}IsPointInside(t,e=s.Open3d.EPSILON){if(!this.IsClosed)throw new Error("Polyline is not closed.");if(!this.IsPlanar(e))throw new Error("Polyline is not planar.");if(this.IsPointOn(t,e))return!1;const r=this.TryGetPlane(e);if(!r.IsPointCoplanar(t,e))return!1;const n=l.Transform.PlaneToPlane(r,o.Plane.PlaneXY),i=t.Transform(n);return this.Transform(n).IsPointInside2D(i)}IsPointInside2D(t){let e=this.Count,r=!1;for(let n=0,i=e-1;n<e;n++)this.Get(n).Y>t.Y!=this.Get(i).Y>t.Y&&t.X<(this.Get(i).X-this.Get(n).X)*(t.Y-this.Get(n).Y)/(this.Get(i).Y-this.Get(n).Y)+this.Get(n).X&&(r=!r),i=n;return r}Transform(t){const e=this.Map((e=>e.Transform(t)));return h.CreateFromPoints(e)}static CreateFromPoints(t){return new h(t)}static Smooth(t,e,r,n){const i=.5*(t.X+r.X),s=.5*(t.Y+r.Y),o=.5*(t.Z+r.Z),l=i===e.X?i:e.X+n*(i-e.X),u=s===e.Y?s:e.Y+n*(s-e.Y),h=o===e.Z?o:e.Z+n*(o-e.Z);return new a.Point3d(l,u,h)}static SignedPolygonArea(t){let e=0,r=t.Count;for(let n=0;n<r;n++){const i=t.Get(n),s=t.Get((n+1)%r);e+=i.X*s.Y-s.X*i.Y}return.5*e}}e.Polyline=h},950:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Transform=void 0;const n=r(561),i=r(35),s=r(226);class o{constructor(t){this.m=t}get Determinant(){const[t,e,r,n,i,s,o,a,l,u,h,c,d,P,m,f]=this.m;return n*(+d*u*o-l*P*o-d*s*h+i*P*h+l*s*m-i*u*m)+a*(+t*u*m-t*P*h+d*e*h-l*e*m+l*P*r-d*u*r)+c*(+t*P*o-t*s*m-d*e*o+i*e*m+d*s*r-i*P*r)+f*(-l*s*r-t*u*o+t*s*h+l*e*o-i*e*h+i*u*r)}get M(){return this.ToArray()}static get Identity(){return new o([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}get IsIdentity(){return this.Equals(o.Identity)}static get ZeroTransformation(){return new o([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1])}get IsZeroTransformation(){return this.Equals(o.ZeroTransformation)}Equals(t){const e=this.M,r=t.M;for(let t=0;t<16;t++)if(!n.Open3dMath.EpsilonEquals(e[t],r[t]))return!1;return!0}Clone(){return new o(this.M)}ToArray(){return[...this.m]}static MultiplyMatrix(t,e){const r=t.m,n=e.m,[i,s,a,l,u,h,c,d,P,m,f,p,Y,Z,X,O]=r,[A,g,M,T,w,I,C,E,b,y,v,x,G,L,S,F]=n;return new o([i*A+s*w+a*b+l*G,i*g+s*I+a*y+l*L,i*M+s*C+a*v+l*S,i*T+s*E+a*x+l*F,u*A+h*w+c*b+d*G,u*g+h*I+c*y+d*L,u*M+h*C+c*v+d*S,u*T+h*E+c*x+d*F,P*A+m*w+f*b+p*G,P*g+m*I+f*y+p*L,P*M+m*C+f*v+p*S,P*T+m*E+f*x+p*F,Y*A+Z*w+X*b+O*G,Y*g+Z*I+X*y+O*L,Y*M+Z*C+X*v+O*S,Y*T+Z*E+X*x+O*F])}MultiplyMatrix(t){return o.MultiplyMatrix(this,t)}static MultiplyScalar(t,e){const r=t.M;for(let t=0;t<16;t++)r[t]*=e;return new o(r)}MultiplyScalar(t){return o.MultiplyScalar(this,t)}static Rotation(t,e=s.Vector3d.ZAxis,r=i.Point3d.Origin){const n=s.Vector3d.CreateFromPoint3d(r),a=o.Translation(n.Reverse()),l=o.RotateAtOrigin(t,e),u=o.Translation(n);return o.CombineTransforms([a,l,u])}static RotateAtOrigin(t,e){const r=Math.cos(t),n=Math.sin(t),i=1-r;if(e.IsZero)throw new Error("Rotation axis should not be zero vector.");const s=(e=e.Unitize()).X,a=e.Y,l=e.Z,u=i*s,h=i*a;return new o([u*s+r,u*a-n*l,u*l+n*a,0,u*a+n*l,h*a+r,h*l-n*s,0,u*l-n*a,h*l+n*s,i*l*l+r,0,0,0,0,1])}static RotationX(t){return o.Rotation(t,s.Vector3d.XAxis)}static RotationY(t){return o.Rotation(t,s.Vector3d.YAxis)}static RotationZ(t){return o.Rotation(t,s.Vector3d.ZAxis)}static RotationZYX(t,e,r){const n=o.RotationZ(t),i=o.RotationY(e),s=o.RotationX(r);return o.CombineTransforms([s,i,n])}static Translation(t){return new o([1,0,0,t.X,0,1,0,t.Y,0,0,1,t.Z,0,0,0,1])}static Scale(t,e){const r=s.Vector3d.CreateFromPoint3d(t),n=o.Translation(r.Reverse()),i=o.ScaleAtOrigin(e,e,e),a=o.Translation(r);return o.CombineTransforms([n,i,a])}static CombineTransforms(t){const e=[...t];e.reverse();let r=o.Identity;for(let t=0;t<e.length;t++)r=r.MultiplyMatrix(e[t]);return r}static ScaleAtOrigin(t,e,r){return new o([t,0,0,0,0,e,0,0,0,0,r,0,0,0,0,1])}static PlanarProjection(t){let e=t.XAxis,r=t.YAxis,n=t.Origin;const i=e.X*e.X+r.X*r.X,s=e.X*e.Y+r.X*r.Y,a=e.X*e.Z+r.X*r.Z,l=e.Y*e.X+r.Y*r.X,u=e.Y*e.Y+r.Y*r.Y,h=e.Y*e.Z+r.Y*r.Z,c=e.Z*e.X+r.Z*r.X,d=e.Z*e.Y+r.Z*r.Y,P=e.Z*e.Z+r.Z*r.Z,m=n.X-i*n.X+s*n.Y+a*n.Z,f=n.Y-l*n.X+u*n.Y+h*n.Z,p=n.Z-c*n.X+d*n.Y+P*n.Z;return new o([i,s,a,m,l,u,h,f,c,d,P,p,0,0,0,1])}static Mirror(t){const e=t.Equation,r=t.Normal,n=r.Multiply(-2*e[3]),i=1-2*r.X*r.X,s=-2*r.X*r.Y,a=-2*r.X*r.Z,l=n.X,u=-2*r.Y*r.X,h=1-2*r.Y*r.Y,c=-2*r.Y*r.Z,d=n.Y,P=-2*r.Z*r.X,m=-2*r.Z*r.Y,f=1-2*r.Z*r.Z,p=n.Z;return new o([i,s,a,l,u,h,c,d,P,m,f,p,0,0,0,1])}static VectorToVector(t,e){const r=e.CrossProduct(t);let n=s.Vector3d.VectorAngle(t,e);return o.RotateAtOrigin(-n,r)}static worldXYToFrame(t,e,r,n){return new o([e.X,r.X,n.X,t.X,e.Y,r.Y,n.Y,t.Y,e.Z,r.Z,n.Z,t.Z,0,0,0,1])}static frameToFramePoint(t,e,r,n,i,s,o,a,l){const u=l.SubtractPoint(t),h=u.DotProduct(e),c=u.DotProduct(r),d=u.DotProduct(n);return i.Add(s.Multiply(h)).Add(o.Multiply(c)).Add(a.Multiply(d))}static frameToFrame(t,e,r,n,s,a,l,u){const h=o.frameToFramePoint(t,e,r,n,s,a,l,u,new i.Point3d(0,0,0)),c=o.frameToFramePoint(t,e,r,n,s,a,l,u,new i.Point3d(1,0,0)),d=o.frameToFramePoint(t,e,r,n,s,a,l,u,new i.Point3d(0,1,0)),P=o.frameToFramePoint(t,e,r,n,s,a,l,u,new i.Point3d(0,0,1));return o.worldXYToFrame(h,c.SubtractPoint(h),d.SubtractPoint(h),P.SubtractPoint(h))}static PlaneToPlane(t,e){return o.frameToFrame(t.Origin,t.XAxis,t.YAxis,t.ZAxis,e.Origin,e.XAxis,e.YAxis,e.ZAxis)}Transpose(){const t=this.M;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,new o(t)}TryGetInverse(){const t=this.M,[e,r,n,i,s,a,l,u,h,c,d,P,m,f,p,Y]=this.m,Z=c*p*u-f*d*u+f*l*P-a*p*P-c*l*Y+a*d*Y,X=m*d*u-h*p*u-m*l*P+s*p*P+h*l*Y-s*d*Y,O=h*f*u-m*c*u+m*a*P-s*f*P-h*a*Y+s*c*Y,A=m*c*l-h*f*l-m*a*d+s*f*d+h*a*p-s*c*p,g=e*Z+r*X+n*O+i*A;if(0===g)return null;const M=1/g;return t[0]=Z*M,t[1]=(f*d*i-c*p*i-f*n*P+r*p*P+c*n*Y-r*d*Y)*M,t[2]=(a*p*i-f*l*i+f*n*u-r*p*u-a*n*Y+r*l*Y)*M,t[3]=(c*l*i-a*d*i-c*n*u+r*d*u+a*n*P-r*l*P)*M,t[4]=X*M,t[5]=(h*p*i-m*d*i+m*n*P-e*p*P-h*n*Y+e*d*Y)*M,t[6]=(m*l*i-s*p*i-m*n*u+e*p*u+s*n*Y-e*l*Y)*M,t[7]=(s*d*i-h*l*i+h*n*u-e*d*u-s*n*P+e*l*P)*M,t[8]=O*M,t[9]=(m*c*i-h*f*i-m*r*P+e*f*P+h*r*Y-e*c*Y)*M,t[10]=(s*f*i-m*a*i+m*r*u-e*f*u-s*r*Y+e*a*Y)*M,t[11]=(h*a*i-s*c*i-h*r*u+e*c*u+s*r*P-e*a*P)*M,t[12]=A*M,t[13]=(h*f*n-m*c*n+m*r*d-e*f*d-h*r*p+e*c*p)*M,t[14]=(m*a*n-s*f*n-m*r*l+e*f*l+s*r*p-e*a*p)*M,t[15]=(s*c*n-h*a*n+h*r*l-e*c*l-s*r*d+e*a*d)*M,new o(t)}toString(){const[t,e,r,n,i,s,o,a,l,u,h,c,d,P,m,f]=this.m;return`R0=(${t}, ${i}, ${l}, ${d}), R1=(${e}, ${s}, ${u}, ${P}), R2=(${r}, ${o}, ${h}, ${m}), R3=(${n}, ${a}, ${c}, ${f})`}}e.Transform=o},226:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Vector3d=void 0;const n=r(653),i=r(561),s=r(614),o=r(35),a=r(950);class l{constructor(t,e,r){this.X=t,this.Y=e,this.Z=r}static CreateFromVector(t){return new l(t.X,t.Y,t.Z)}static CreateFromPoint3d(t){return new l(t.X,t.Y,t.Z)}get IsUnitVector(){return i.Open3dMath.EpsilonEquals(this.Length,1)}get IsZero(){return i.Open3dMath.EpsilonEquals(this.X,0)&&i.Open3dMath.EpsilonEquals(this.Y,0)&&i.Open3dMath.EpsilonEquals(this.Z,0)}get Length(){return Math.hypot(this.X,this.Y,this.Z)}static Add(t,e){return new l(t.X+e.X,t.Y+e.Y,t.Z+e.Z)}static AddToPoint(t,e){return new o.Point3d(t.X+e.X,t.Y+e.Y,t.Z+e.Z)}Add(t){return l.Add(this,t)}AddToPoint(t){return l.AddToPoint(this,t)}static Subtract(t,e){return new l(t.X-e.X,t.Y-e.Y,t.Z-e.Z)}Subtract(t){return l.Subtract(this,t)}static Multiply(t,e){return new l(t.X*e,t.Y*e,t.Z*e)}Multiply(t){return l.Multiply(this,t)}static Divide(t,e){if(0===e)throw new Error("Division by zero");const r=1/e;return new l(t.X*r,t.Y*r,t.Z*r)}Divide(t){return l.Divide(this,t)}static Interpolate(t,e,r){return new l(t.X+(e.X-t.X)*r,t.Y+(e.Y-t.Y)*r,t.Z+(e.Z-t.Z)*r)}static DotProduct(t,e){return t.X*e.X+t.Y*e.Y+t.Z*e.Z}DotProduct(t){return l.DotProduct(this,t)}static CrossProduct(t,e){return new l(t.Y*e.Z-e.Y*t.Z,t.Z*e.X-e.Z*t.X,t.X*e.Y-e.X*t.Y)}CrossProduct(t){return l.CrossProduct(this,t)}static Distance(t,e){return e.Subtract(t).Length}DistanceTo(t){return l.Distance(this,t)}static Equals(t,e){return i.Open3dMath.EpsilonEquals(t.X,e.X)&&i.Open3dMath.EpsilonEquals(t.Y,e.Y)&&i.Open3dMath.EpsilonEquals(t.Z,e.Z)}Equals(t){return l.Equals(this,t)}static VectorAngle(t,e){if(t.IsZero||e.IsZero)throw new Error("Cannot compute angle of zero-length vector.");let r=l.DotProduct(t,e)/(t.Length*e.Length);return r=i.Open3dMath.Clamp(r,-1,1),Math.acos(r)}static PositiveVectorAngle(t,e,r){const n=r instanceof s.Plane?r:s.Plane.CreateFromNormal(o.Point3d.Origin,null!=r?r:l.ZAxis),i=a.Transform.PlaneToPlane(n,s.Plane.PlaneXY),u=t.Transform(i),h=e.Transform(i);if(u.Z=0,h.Z=0,u.IsZero||h.IsZero)throw new Error("Cannot compute angle of zero-length vector.");const c=Math.atan2(h.Y,h.X)-Math.atan2(u.Y,u.X);return c<0?c+2*Math.PI:c}VectorAngle(t){return l.VectorAngle(this,t)}static Reverse(t){return new l(-t.X,-t.Y,-t.Z)}Reverse(){return l.Reverse(this)}static Unitize(t){var e=t.Length;if(0===e)throw new Error("Cannot unitize a zero-length vector.");return new l(t.X/e,t.Y/e,t.Z/e)}Unitize(){return l.Unitize(this)}IsTiny(t=n.Open3d.EPSILON){return Math.abs(this.X)<t&&Math.abs(this.Y)<t&&Math.abs(this.Z)<t}static IsParallel(t,e){if(t.IsZero||e.IsZero)return n.Open3d.ParallelIndicator.Parallel;const r=l.VectorAngle(t,e);return i.Open3dMath.EpsilonEquals(r,0,n.Open3d.ANGLE_EPSILON)?n.Open3d.ParallelIndicator.Parallel:i.Open3dMath.EpsilonEquals(r,Math.PI,n.Open3d.ANGLE_EPSILON)?n.Open3d.ParallelIndicator.AntiParallel:n.Open3d.ParallelIndicator.NotParallel}IsParallelTo(t){return l.IsParallel(this,t)}static IsPerpendicular(t,e){if(t.IsZero||e.IsZero)return!0;const r=l.VectorAngle(t,e);return!!i.Open3dMath.EpsilonEquals(r,Math.PI/2,n.Open3d.ANGLE_EPSILON)||!!i.Open3dMath.EpsilonEquals(r,-Math.PI/2,n.Open3d.ANGLE_EPSILON)}IsPerpendicularTo(t){return l.IsPerpendicular(this,t)}VectorRotate(t,e){const r=a.Transform.RotateAtOrigin(t,e);return this.Transform(r)}GetPerpendicularVector(){let t,e,r,n,i;r=2,Math.abs(this.Y)>Math.abs(this.X)?Math.abs(this.Z)>Math.abs(this.Y)?(t=2,e=1,r=0,n=this.Z,i=-this.Y):Math.abs(this.Z)>=Math.abs(this.X)?(t=1,e=2,r=0,n=this.Y,i=-this.Z):(t=1,e=0,r=2,n=this.Y,i=-this.X):Math.abs(this.Z)>Math.abs(this.X)?(t=2,e=0,r=1,n=this.Z,i=-this.X):Math.abs(this.Z)>Math.abs(this.Y)?(t=0,e=2,r=1,n=this.X,i=-this.Z):(t=0,e=1,r=2,n=this.X,i=-this.Y);let s=[0,0,0];return s[t]=i,s[e]=n,s[r]=0,new l(s[0],s[1],s[2]).Unitize()}Transform(t){let e,r,n;const i=t.M;return i[3]=0,i[7]=0,i[11]=0,e=i[0]*this.X+i[1]*this.Y+i[2]*this.Z+i[3],r=i[4]*this.X+i[5]*this.Y+i[6]*this.Z+i[7],n=i[8]*this.X+i[9]*this.Y+i[10]*this.Z+i[11],new l(e,r,n)}toString(){return`Vector3d [${this.X}, ${this.Y}, ${this.Z}]`}}e.Vector3d=l,l.XAxis=new l(1,0,0),l.YAxis=new l(0,1,0),l.ZAxis=new l(0,0,1),l.Zero=new l(0,0,0)}},e={};function r(n){var i=e[n];if(void 0!==i)return i.exports;var s=e[n]={exports:{}};return t[n](s,s.exports,r),s.exports}var n={};return(()=>{var t=n;Object.defineProperty(t,"__esModule",{value:!0}),t.Open3d=t.Open3dMath=t.Intersection=t.Transform=t.Plane=t.Polyline=t.Line=t.Point3d=t.Vector3d=void 0;var e=r(226);Object.defineProperty(t,"Vector3d",{enumerable:!0,get:function(){return e.Vector3d}});var i=r(35);Object.defineProperty(t,"Point3d",{enumerable:!0,get:function(){return i.Point3d}});var s=r(582);Object.defineProperty(t,"Line",{enumerable:!0,get:function(){return s.Line}});var o=r(465);Object.defineProperty(t,"Polyline",{enumerable:!0,get:function(){return o.Polyline}});var a=r(614);Object.defineProperty(t,"Plane",{enumerable:!0,get:function(){return a.Plane}});var l=r(950);Object.defineProperty(t,"Transform",{enumerable:!0,get:function(){return l.Transform}});var u=r(387);Object.defineProperty(t,"Intersection",{enumerable:!0,get:function(){return u.Intersection}});var h=r(561);Object.defineProperty(t,"Open3dMath",{enumerable:!0,get:function(){return h.Open3dMath}});var c=r(653);Object.defineProperty(t,"Open3d",{enumerable:!0,get:function(){return c.Open3d}})})(),n})()));