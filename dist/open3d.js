!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.Open3d=e():t.Open3d=e()}(this,(()=>(()=>{"use strict";var t={387:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Intersection=void 0;const n=r(975),i=r(582),s=r(653),o=r(561),a=r(614),l=r(35);class u{constructor(){throw new Error("Cannot initialize an intersection instance.")}static LineLineTParameters(t,e){const r=t.From.SubtractPoint(e.From),n=e.Direction,i=t.Direction,s=r.DotProduct(n),a=n.DotProduct(i),l=r.DotProduct(i),u=n.DotProduct(n),h=i.DotProduct(i)*u-a*a,c=s*a-l*u;if(o.Open3dMath.EpsilonEquals(h,0))return null;const d=c/h;return[d,(s+a*d)/u]}static LineLine(t,e,r=!1,n=s.Open3d.EPSILON){const i=u.CrossingLineLine(t,e,r,n);return i?i.PointA.AddPoint(i.PointB).Multiply(.5):null}static CrossingLineLine(t,e,r=!1,i=1/0){if(!t.IsValid||!e.IsValid)return null;const s=u.LineLineTParameters(t,e);if(!s)return null;const[o,a]=s,l=t.PointAt(o),h=e.PointAt(a),c=l.DistanceTo(h);return r&&(o<0||o>1||a<0||a>1)||c>i?null:new n.IntersectionEvent(o,a,l,h)}static LinePlane(t,e,r=!1){const n=t.From.SubtractPoint(e.Origin).DotProduct(e.Normal),i=t.UnitDirection.DotProduct(e.Normal);if(o.Open3dMath.EpsilonEquals(i,0))return null;const s=-n/i;return r&&(s<0||s>t.Length)?null:t.From.Add(t.UnitDirection.Multiply(s))}static PlanePlane(t,e){if(t.Normal.IsParallelTo(e.Normal))return null;const r=e.Normal.CrossProduct(t.Normal),n=t.Origin.AddPoint(e.Origin).Multiply(.5),s=a.Plane.CreateFromNormal(n,r),o=u.PlanePlanePlane(t,e,s);return null==o?null:new i.Line(o,o.Add(s.Normal))}static PlanePlanePlane(t,e,r){const n=t.Equation,i=e.Equation,s=r.Equation,a=[n[0],n[1],n[2],i[0],i[1],i[2],s[0],s[1],s[2]],u=[-n[3],-i[3],-s[3]],[h,c,d,P,m,p,f,Y,X]=a,O=h*(m*X-p*Y)-c*(P*X-p*f)+d*(P*Y-m*f);if(o.Open3dMath.EpsilonEquals(O,0))return null;const Z=1/O,A=Z*(m*X-p*Y)*u[0]+Z*(d*Y-c*X)*u[1]+Z*(c*p-d*m)*u[2],g=Z*(p*f-P*X)*u[0]+Z*(h*X-d*f)*u[1]+Z*(d*P-h*p)*u[2],M=Z*(P*Y-m*f)*u[0]+Z*(c*f-h*Y)*u[1]+Z*(h*m-c*P)*u[2];return new l.Point3d(A,g,M)}}e.Intersection=u},975:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.IntersectionEvent=void 0,e.IntersectionEvent=class{constructor(t,e,r,n){this.ParameterA=t,this.ParameterB=e,this.PointA=r,this.PointB=n}}},582:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Line=void 0;const n=r(653),i=r(561);class s{constructor(t,e){this.From=t,this.To=e}get IsValid(){return!this.From.Equals(this.To)}get Direction(){if(!this.IsValid)throw new Error("Cannot get direction of an invalid line.");return this.To.SubtractPoint(this.From)}get UnitDirection(){return this.Direction.Unitize()}get Length(){return this.To.DistanceTo(this.From)}set Length(t){let e=this.UnitDirection;t<0&&(e=e.Reverse()),this.To=this.From.Add(e.Multiply(Math.abs(t)))}Clone(){return new s(this.From,this.To)}PointAt(t){if(!this.IsValid)throw new Error("Cannot evaluate an invalid line.");return this.Direction.Multiply(t).AddToPoint(this.From)}PointAtLength(t){if(!this.IsValid)throw new Error("Cannot evaluate an invalid line.");return this.UnitDirection.Multiply(t).AddToPoint(this.From)}ClosestParameter(t,e=!1){if(!this.IsValid)throw new Error("Invalid line does not have a closest point.");const r=t.SubtractPoint(this.From),n=this.To.SubtractPoint(this.From),s=n.DotProduct(n);let o=n.DotProduct(r)/s;return e&&(o=i.Open3dMath.Clamp(o,0,1)),o}ClosestPoint(t,e=!1){const r=this.ClosestParameter(t,e);return this.PointAt(r)}DistanceTo(t,e=!1){return this.ClosestPoint(t,e).DistanceTo(t)}Equals(t){return this.From.Equals(t.From)&&this.To.Equals(t.To)}IsPointOn(t,e=!1,r=n.Open3d.EPSILON){return this.DistanceTo(t,e)<=r}Extend(t,e){if(!this.IsValid)throw new Error("Cannot extend an invalid line.");const r=this.UnitDirection.Multiply(-t).AddToPoint(this.From),n=this.UnitDirection.Multiply(e).AddToPoint(this.To);return new s(r,n)}Flip(){return new s(this.To,this.From)}Transform(t){const e=this.From.Transform(t),r=this.To.Transform(t);return new s(e,r)}}e.Line=s},462:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Point3dList=e.List=void 0;class r{constructor(t){this.items=void 0===t?[]:t}Get(t){return this.items[t]}Set(t,e){this.items[t]=e}get Count(){return this.items.length}get First(){return this.items[0]}set First(t){this.items[0]=t}get Last(){return this.items[this.Count-1]}set Last(t){this.items[this.Count-1]=t}Clear(){this.items.length=0}Add(t){this.items.push(t)}AddRange(t){this.items.push(...t)}Contains(t,e){return this.items.includes(t,e)}Exists(t){return this.items.some(t)}Find(t){return this.items.find(t)}FindIndex(t){return this.items.findIndex(t)}FindAll(t){return this.items.filter(t)}ForEach(t){this.items.forEach(t)}Insert(t,e){this.items.splice(t,0,e)}InsertRange(t,e){this.items.splice(t,0,...e)}get NullOrUndefinedCount(){return this.items.filter((t=>null==t)).length}Reduce(t){return this.items.reduce(t)}Pop(){return this.items.pop()}Shift(){return this.items.shift()}Filter(t){return this.items.filter(t)}Map(t){return this.items.map(t)}Remove(t){const e=this.items.indexOf(t);e>-1&&this.items.splice(e,1)}RemoveBy(t){const e=this.Find(t);e&&this.Remove(e)}RemoveAll(t){this.items.filter(t).forEach((t=>this.Remove(t)))}Sort(t){this.items.sort(t)}Reverse(){return this.items.reverse()}}e.List=r,e.Point3dList=class extends r{}},653:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Open3d=void 0,function(t){let e;!function(t){t[t.Parallel=1]="Parallel",t[t.NotParallel=0]="NotParallel",t[t.AntiParallel=-1]="AntiParallel"}(e=t.ParallelIndicator||(t.ParallelIndicator={})),t.EPSILON=1e-6,t.ANGLE_EPSILON=.001}(e.Open3d||(e.Open3d={}))},561:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Open3dMath=void 0;const n=r(653);class i{static Clamp(t,e,r){if(e>r){const t=e;e=r,r=t}return Math.min(Math.max(t,e),r)}static ToDegrees(t){return 180*t/Math.PI}static ToRadians(t){return t*Math.PI/180}}e.Open3dMath=i,i.EpsilonEquals=(t,e,r=n.Open3d.EPSILON)=>Math.abs(t-e)<r},614:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Plane=void 0;const n=r(582),i=r(226),s=r(35),o=r(653);class a{constructor(t,e,r){if(e.IsTiny()||r.IsTiny())throw new Error("The input axis is not valid.");if(e.IsParallelTo(r))throw new Error("XAxis and YAxis should not be parallel.");e=e.Unitize(),r=r.Unitize();const n=e.CrossProduct(r).Unitize();r=n.CrossProduct(e).Unitize(),this.Origin=t,this.XAxis=e,this.YAxis=r,this.ZAxis=n}get Normal(){return this.ZAxis.Unitize()}get XAxisLine(){return new n.Line(this.Origin,this.Origin.Add(this.XAxis))}get YAxisLine(){return new n.Line(this.Origin,this.Origin.Add(this.YAxis))}get ZAxisLine(){return new n.Line(this.Origin,this.Origin.Add(this.ZAxis))}get Equation(){const{X:t,Y:e,Z:r}=this.Normal;return[t,e,r,-t*this.Origin.X-e*this.Origin.Y-r*this.Origin.Z]}static get PlaneXY(){return new a(s.Point3d.Origin,i.Vector3d.XAxis,i.Vector3d.YAxis)}static get PlaneZX(){return new a(s.Point3d.Origin,i.Vector3d.ZAxis,i.Vector3d.XAxis)}static get PlaneYZ(){return new a(s.Point3d.Origin,i.Vector3d.YAxis,i.Vector3d.ZAxis)}PointAt(t,e){return this.Origin.Add(this.XAxis.Multiply(t)).Add(this.YAxis.Multiply(e))}ClosestParameter(t){return[this.XAxisLine.ClosestParameter(t),this.YAxisLine.ClosestParameter(t)]}ClosestPoint(t){return this.PointAt(...this.ClosestParameter(t))}DistanceTo(t){const e=t.SubtractPoint(this.Origin),r=t.DistanceTo(this.ClosestPoint(t));return e.DotProduct(this.ZAxis)>0?r:-r}Clone(){return new a(this.Origin,this.XAxis,this.YAxis)}Flip(){return new a(this.Origin,this.YAxis,this.XAxis)}IsPointCoplanar(t,e=o.Open3d.EPSILON){return this.ClosestPoint(t).DistanceTo(t)<e}IsLineCoplanar(t,e=o.Open3d.EPSILON){return this.IsPointCoplanar(t.From,e)&&this.IsPointCoplanar(t.To,e)}static CreateFromNormal(t,e){const r=e.Unitize(),n=e.GetPerpendicularVector(),i=r.CrossProduct(n).Unitize();return new a(t,n,i)}static CreateFromFrame(t,e,r){return new a(t,e,r)}static CreateFrom3Points(t,e,r){const n=e.SubtractPoint(t),i=r.SubtractPoint(t),s=n.CrossProduct(i).CrossProduct(n);return new a(t,n,s)}Transform(t){const e=this.Origin.Transform(t),r=this.XAxis.Transform(t),n=this.YAxis.Transform(t);return new a(e,r,n)}}e.Plane=a},35:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Point3d=void 0;const n=r(561),i=r(226);class s{constructor(t,e,r){this.X=t,this.Y=e,this.Z=r}static CreateFromVector(t){return new s(t.X,t.Y,t.Z)}static CreateFromPoint3d(t){return new s(t.X,t.Y,t.Z)}static get Origin(){return new s(0,0,0)}static Add(t,e){return new s(t.X+e.X,t.Y+e.Y,t.Z+e.Z)}static AddPoint(t,e){return new s(t.X+e.X,t.Y+e.Y,t.Z+e.Z)}Add(t){return s.Add(this,t)}AddPoint(t){return s.AddPoint(this,t)}static Subtract(t,e){return new s(t.X-e.X,t.Y-e.Y,t.Z-e.Z)}static SubtractPoint(t,e){return new i.Vector3d(t.X-e.X,t.Y-e.Y,t.Z-e.Z)}Subtract(t){return s.Subtract(this,t)}SubtractPoint(t){return s.SubtractPoint(this,t)}static Multiply(t,e){return new s(t.X*e,t.Y*e,t.Z*e)}Multiply(t){return s.Multiply(this,t)}static Divide(t,e){if(0===e)throw new Error("Division by zero");const r=1/e;return new s(t.X*r,t.Y*r,t.Z*r)}Divide(t){return s.Divide(this,t)}static Interpolate(t,e,r){return new s(t.X+(e.X-t.X)*r,t.Y+(e.Y-t.Y)*r,t.Z+(e.Z-t.Z)*r)}static Distance(t,e){return Math.hypot(t.X-e.X,t.Y-e.Y,t.Z-e.Z)}DistanceTo(t){return s.Distance(this,t)}static Equals(t,e){return n.Open3dMath.EpsilonEquals(t.X,e.X)&&n.Open3dMath.EpsilonEquals(t.Y,e.Y)&&n.Open3dMath.EpsilonEquals(t.Z,e.Z)}Equals(t){return s.Equals(this,t)}Transform(t){let e,r,n;const i=t.M;return e=i[0]*this.X+i[1]*this.Y+i[2]*this.Z+i[3],r=i[4]*this.X+i[5]*this.Y+i[6]*this.Z+i[7],n=i[8]*this.X+i[9]*this.Y+i[10]*this.Z+i[11],new s(e,r,n)}toString(){return`Point3d [${this.X}, ${this.Y}, ${this.Z}]`}}e.Point3d=s},465:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Polyline=void 0;const n=r(582),i=r(462),s=r(653),o=r(614),a=r(35),l=r(950),u=r(226);class h extends i.Point3dList{constructor(t){super(t)}get CenterPoint(){const t=this.Count;if(0===t)return a.Point3d.Origin;if(1===t)return this.Get(0);let e=a.Point3d.Origin,r=0;for(let n=0;n<t-1;n++){let t=this.Get(n),i=this.Get(n+1),s=t.DistanceTo(i);e=e.AddPoint(a.Point3d.AddPoint(t,i).Multiply(.5*s)),r+=s}return e=e.Divide(r),e}get IsValid(){if(this.Count<2)return!1;for(let t=1;t<this.Count;t++)if(this.Get(t).Equals(this.Get(t-1)))return!1;return!(this.Count<4&&this.IsClosed)}get SegmentCount(){return Math.max(0,this.Count-1)}get IsClosed(){return this.Count>2&&this.First.Equals(this.Last)}get Length(){if(this.Count<2)return 0;let t=0;for(let e=0;e<this.Count-1;e++)t+=this.Get(e).DistanceTo(this.Get(e+1));return t}IsClosedWithinTolerance(t){return!(this.Count<=2)&&this.First.DistanceTo(this.Last)<=t}PointAt(t){const e=this.Count;if(e<1)return a.Point3d.Origin;if(1==e)return this.First;const r=Math.floor(t);if(r<0)return this.Get(0);if(r>=e-1)return this.Get(e-1);if((t-=r)<=0)return this.Get(r);if(t>=1)return this.Get(r+1);const n=this.Get(r),i=this.Get(r+1);let s=1-t;return new a.Point3d(n.X==i.X?n.X:s*n.X+t*i.X,n.Y==i.Y?n.Y:s*n.Y+t*i.Y,n.Z==i.Z?n.Z:s*n.Z+t*i.Z)}SegmentAt(t){return t<0||t>=this.Count-1?null:(t=Math.floor(t),new n.Line(this.Get(t),this.Get(t+1)))}TangentAt(t){const e=this.Count;if(e<2)return u.Vector3d.Zero;let r=Math.floor(t);return r<0?r=0:r>=e-1&&(r=e-2),this.Get(r+1).SubtractPoint(this.Get(r)).Unitize()}Trim(t,e){let r=this.Count-1,n=Math.floor(t),i=Math.floor(e),s=t-n,o=e-i;s<0&&(s=0),s>=1&&(n++,s=0),o<0&&(o=0),o>=1&&(i++,o=0),n<0&&(n=0,s=0),n>=r&&(n=r,s=0),i<0&&(i=0,o=0),i>=r&&(i=r,o=0);const a=h.CreateFromPoints([this.PointAt(t)]);for(let t=n+1;t<=i;t++)a.Add(this.Get(t));return o>0&&a.Add(this.PointAt(e)),a}ClosestPoint(t){const e=this.ClosestParameter(t);return this.PointAt(e)}ClosestParameter(t){const e=this.Count;if(e<2)return 0;let r=0,i=0,s=Number.MAX_VALUE;for(let o=0;o<e-1;o++){const e=new n.Line(this.Get(o),this.Get(o+1));let a,l;e.Direction.IsTiny()?(l=0,a=this.Get(o).DistanceTo(t)):(l=e.ClosestParameter(t),l<=0?l=0:l>1&&(l=1),a=e.PointAt(l).DistanceTo(t)),a<s&&(s=a,i=l,r=o)}return r+i}GetSegments(){if(this.Count<2)return[];const t=[];for(let e=0;e<this.Count-1;e++)t.push(new n.Line(this.Get(e),this.Get(e+1)));return t}DeleteShortSegments(t=s.Open3d.EPSILON){const e=this.Count;if(e<3)return h.CreateFromPoints(this.items);const r=new Array(e);r[0]=!0,r[e-1]=!0;let n=0;for(let i=1;i<e-1;i++)this.Get(i).DistanceTo(this.Get(n))<=t?r[i]=!1:(n=i,r[i]=!0);for(let n=e-2;n>0;n--)if(r[n]){if(!(this.Get(n).DistanceTo(this.Get(e-1))<=t))break;r[n]=!1}const i=new Array(e);let o=0;for(let t=0;t<e;t++)r[t]&&(i[o]=this.Get(t),o++);return h.CreateFromPoints(i)}Smooth(t){const e=this.Count;if(e<3)return null;let r=e-1;t*=.5;const n=new Array(e);this.IsClosed?(n[0]=h.Smooth(this.Get(r-1),this.Get(0),this.Get(1),t),n[r]=n[0]):(n[0]=this.Get(0),n[r]=this.Get(r));for(let e=1;e<r;e++)n[e]=h.Smooth(this.Get(e-1),this.Get(e),this.Get(e+1),t);return h.CreateFromPoints(n)}IsPlanar(t=s.Open3d.EPSILON){const e=this.Count;if(e<3)return!1;const r=o.Plane.CreateFrom3Points(this.Get(0),this.Get(1),this.Get(2));for(let n=3;n<e;n++)if(!r.IsPointCoplanar(this.Get(n),t))return!1;return!0}TryGetPlane(t=s.Open3d.EPSILON){return this.IsPlanar(t)?o.Plane.CreateFrom3Points(this.Get(0),this.Get(1),this.Get(2)):null}TryGetArea(t=s.Open3d.EPSILON){if(this.IsPlanar()&&this.IsClosed){const e=this.TryGetPlane(t),r=this.Transform(l.Transform.PlaneToPlane(e,o.Plane.PlaneXY));return Math.abs(h.SignedPolygonArea(r))}return null}IsPointOn(t,e=s.Open3d.EPSILON){const r=this.Count;if(r<2)return!1;for(let i=0;i<r-1;i++)if(new n.Line(this.Get(i),this.Get(i+1)).IsPointOn(t,!0,e))return!0;return!1}IsPointInside(t,e=s.Open3d.EPSILON){if(!this.IsClosed)throw new Error("Polyline is not closed.");if(!this.IsPlanar(e))throw new Error("Polyline is not planar.");if(this.IsPointOn(t,e))return!1;const r=this.TryGetPlane(e);if(!r.IsPointCoplanar(t,e))return!1;const n=l.Transform.PlaneToPlane(r,o.Plane.PlaneXY),i=t.Transform(n);return this.Transform(n).IsPointInside2D(i)}IsPointInside2D(t){let e=this.Count,r=!1;for(let n=0,i=e-1;n<e;n++)this.Get(n).Y>t.Y!=this.Get(i).Y>t.Y&&t.X<(this.Get(i).X-this.Get(n).X)*(t.Y-this.Get(n).Y)/(this.Get(i).Y-this.Get(n).Y)+this.Get(n).X&&(r=!r),i=n;return r}Transform(t){const e=this.Map((e=>e.Transform(t)));return h.CreateFromPoints(e)}static CreateFromPoints(t){return new h(t)}static Smooth(t,e,r,n){const i=.5*(t.X+r.X),s=.5*(t.Y+r.Y),o=.5*(t.Z+r.Z),l=i===e.X?i:e.X+n*(i-e.X),u=s===e.Y?s:e.Y+n*(s-e.Y),h=o===e.Z?o:e.Z+n*(o-e.Z);return new a.Point3d(l,u,h)}static SignedPolygonArea(t){let e=0,r=t.Count;for(let n=0;n<r;n++){const i=t.Get(n),s=t.Get((n+1)%r);e+=i.X*s.Y-s.X*i.Y}return.5*e}}e.Polyline=h},950:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Transform=void 0;const n=r(561),i=r(35),s=r(226);class o{constructor(t){this.m=t}get Determinant(){const[t,e,r,n,i,s,o,a,l,u,h,c,d,P,m,p]=this.m;return n*(+d*u*o-l*P*o-d*s*h+i*P*h+l*s*m-i*u*m)+a*(+t*u*m-t*P*h+d*e*h-l*e*m+l*P*r-d*u*r)+c*(+t*P*o-t*s*m-d*e*o+i*e*m+d*s*r-i*P*r)+p*(-l*s*r-t*u*o+t*s*h+l*e*o-i*e*h+i*u*r)}get M(){return this.ToArray()}static get Identity(){return new o([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}get IsIdentity(){return this.Equals(o.Identity)}static get ZeroTransformation(){return new o([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1])}get IsZeroTransformation(){return this.Equals(o.ZeroTransformation)}Equals(t){const e=this.M,r=t.M;for(let t=0;t<16;t++)if(!n.Open3dMath.EpsilonEquals(e[t],r[t]))return!1;return!0}Clone(){return new o(this.M)}ToArray(){return[...this.m]}static MultiplyMatrix(t,e){const r=t.m,n=e.m,[i,s,a,l,u,h,c,d,P,m,p,f,Y,X,O,Z]=r,[A,g,M,I,T,E,w,C,y,b,v,L,G,x,D,S]=n;return new o([i*A+s*T+a*y+l*G,i*g+s*E+a*b+l*x,i*M+s*w+a*v+l*D,i*I+s*C+a*L+l*S,u*A+h*T+c*y+d*G,u*g+h*E+c*b+d*x,u*M+h*w+c*v+d*D,u*I+h*C+c*L+d*S,P*A+m*T+p*y+f*G,P*g+m*E+p*b+f*x,P*M+m*w+p*v+f*D,P*I+m*C+p*L+f*S,Y*A+X*T+O*y+Z*G,Y*g+X*E+O*b+Z*x,Y*M+X*w+O*v+Z*D,Y*I+X*C+O*L+Z*S])}MultiplyMatrix(t){return o.MultiplyMatrix(this,t)}static MultiplyScalar(t,e){const r=t.M;for(let t=0;t<16;t++)r[t]*=e;return new o(r)}MultiplyScalar(t){return o.MultiplyScalar(this,t)}static Rotation(t,e=s.Vector3d.ZAxis,r=i.Point3d.Origin){const n=s.Vector3d.CreateFromPoint3d(r),a=o.Translation(n.Reverse()),l=o.RotateAtOrigin(t,e),u=o.Translation(n);return o.CombineTransforms([a,l,u])}static RotateAtOrigin(t,e){const r=Math.cos(t),n=Math.sin(t),i=1-r;if(e.IsZero)throw new Error("Rotation axis should not be zero vector.");const s=(e=e.Unitize()).X,a=e.Y,l=e.Z,u=i*s,h=i*a;return new o([u*s+r,u*a-n*l,u*l+n*a,0,u*a+n*l,h*a+r,h*l-n*s,0,u*l-n*a,h*l+n*s,i*l*l+r,0,0,0,0,1])}static RotationX(t){return o.Rotation(t,s.Vector3d.XAxis)}static RotationY(t){return o.Rotation(t,s.Vector3d.YAxis)}static RotationZ(t){return o.Rotation(t,s.Vector3d.ZAxis)}static RotationZYX(t,e,r){const n=o.RotationZ(t),i=o.RotationY(e),s=o.RotationX(r);return o.CombineTransforms([s,i,n])}static Translation(t){return new o([1,0,0,t.X,0,1,0,t.Y,0,0,1,t.Z,0,0,0,1])}static Scale(t,e){const r=s.Vector3d.CreateFromPoint3d(t),n=o.Translation(r.Reverse()),i=o.ScaleAtOrigin(e,e,e),a=o.Translation(r);return o.CombineTransforms([n,i,a])}static CombineTransforms(t){const e=[...t];e.reverse();let r=o.Identity;for(let t=0;t<e.length;t++)r=r.MultiplyMatrix(e[t]);return r}static ScaleAtOrigin(t,e,r){return new o([t,0,0,0,0,e,0,0,0,0,r,0,0,0,0,1])}static PlanarProjection(t){let e=t.XAxis,r=t.YAxis,n=t.Origin;const i=e.X*e.X+r.X*r.X,s=e.X*e.Y+r.X*r.Y,a=e.X*e.Z+r.X*r.Z,l=e.Y*e.X+r.Y*r.X,u=e.Y*e.Y+r.Y*r.Y,h=e.Y*e.Z+r.Y*r.Z,c=e.Z*e.X+r.Z*r.X,d=e.Z*e.Y+r.Z*r.Y,P=e.Z*e.Z+r.Z*r.Z,m=n.X-i*n.X+s*n.Y+a*n.Z,p=n.Y-l*n.X+u*n.Y+h*n.Z,f=n.Z-c*n.X+d*n.Y+P*n.Z;return new o([i,s,a,m,l,u,h,p,c,d,P,f,0,0,0,1])}static Mirror(t){const e=t.Equation,r=t.Normal,n=r.Multiply(-2*e[3]),i=1-2*r.X*r.X,s=-2*r.X*r.Y,a=-2*r.X*r.Z,l=n.X,u=-2*r.Y*r.X,h=1-2*r.Y*r.Y,c=-2*r.Y*r.Z,d=n.Y,P=-2*r.Z*r.X,m=-2*r.Z*r.Y,p=1-2*r.Z*r.Z,f=n.Z;return new o([i,s,a,l,u,h,c,d,P,m,p,f,0,0,0,1])}static VectorToVector(t,e){const r=e.CrossProduct(t);let n=s.Vector3d.VectorAngle(t,e);return o.RotateAtOrigin(-n,r)}static worldXYToFrame(t,e,r,n){return new o([e.X,r.X,n.X,t.X,e.Y,r.Y,n.Y,t.Y,e.Z,r.Z,n.Z,t.Z,0,0,0,1])}static frameToFramePoint(t,e,r,n,i,s,o,a,l){const u=l.SubtractPoint(t),h=u.DotProduct(e),c=u.DotProduct(r),d=u.DotProduct(n);return i.Add(s.Multiply(h)).Add(o.Multiply(c)).Add(a.Multiply(d))}static frameToFrame(t,e,r,n,s,a,l,u){const h=o.frameToFramePoint(t,e,r,n,s,a,l,u,new i.Point3d(0,0,0)),c=o.frameToFramePoint(t,e,r,n,s,a,l,u,new i.Point3d(1,0,0)),d=o.frameToFramePoint(t,e,r,n,s,a,l,u,new i.Point3d(0,1,0)),P=o.frameToFramePoint(t,e,r,n,s,a,l,u,new i.Point3d(0,0,1));return o.worldXYToFrame(h,c.SubtractPoint(h),d.SubtractPoint(h),P.SubtractPoint(h))}static PlaneToPlane(t,e){return o.frameToFrame(t.Origin,t.XAxis,t.YAxis,t.ZAxis,e.Origin,e.XAxis,e.YAxis,e.ZAxis)}Transpose(){const t=this.M;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,new o(t)}TryGetInverse(){const t=this.M,[e,r,n,i,s,a,l,u,h,c,d,P,m,p,f,Y]=this.m,X=c*f*u-p*d*u+p*l*P-a*f*P-c*l*Y+a*d*Y,O=m*d*u-h*f*u-m*l*P+s*f*P+h*l*Y-s*d*Y,Z=h*p*u-m*c*u+m*a*P-s*p*P-h*a*Y+s*c*Y,A=m*c*l-h*p*l-m*a*d+s*p*d+h*a*f-s*c*f,g=e*X+r*O+n*Z+i*A;if(0===g)return null;const M=1/g;return t[0]=X*M,t[1]=(p*d*i-c*f*i-p*n*P+r*f*P+c*n*Y-r*d*Y)*M,t[2]=(a*f*i-p*l*i+p*n*u-r*f*u-a*n*Y+r*l*Y)*M,t[3]=(c*l*i-a*d*i-c*n*u+r*d*u+a*n*P-r*l*P)*M,t[4]=O*M,t[5]=(h*f*i-m*d*i+m*n*P-e*f*P-h*n*Y+e*d*Y)*M,t[6]=(m*l*i-s*f*i-m*n*u+e*f*u+s*n*Y-e*l*Y)*M,t[7]=(s*d*i-h*l*i+h*n*u-e*d*u-s*n*P+e*l*P)*M,t[8]=Z*M,t[9]=(m*c*i-h*p*i-m*r*P+e*p*P+h*r*Y-e*c*Y)*M,t[10]=(s*p*i-m*a*i+m*r*u-e*p*u-s*r*Y+e*a*Y)*M,t[11]=(h*a*i-s*c*i-h*r*u+e*c*u+s*r*P-e*a*P)*M,t[12]=A*M,t[13]=(h*p*n-m*c*n+m*r*d-e*p*d-h*r*f+e*c*f)*M,t[14]=(m*a*n-s*p*n-m*r*l+e*p*l+s*r*f-e*a*f)*M,t[15]=(s*c*n-h*a*n+h*r*l-e*c*l-s*r*d+e*a*d)*M,new o(t)}toString(){const[t,e,r,n,i,s,o,a,l,u,h,c,d,P,m,p]=this.m;return`R0=(${t}, ${i}, ${l}, ${d}), R1=(${e}, ${s}, ${u}, ${P}), R2=(${r}, ${o}, ${h}, ${m}), R3=(${n}, ${a}, ${c}, ${p})`}}e.Transform=o},226:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Vector3d=void 0;const n=r(653),i=r(561),s=r(35),o=r(950);class a{constructor(t,e,r){this.X=t,this.Y=e,this.Z=r}static CreateFromVector(t){return new a(t.X,t.Y,t.Z)}static CreateFromPoint3d(t){return new a(t.X,t.Y,t.Z)}get IsUnitVector(){return i.Open3dMath.EpsilonEquals(this.Length,1)}get IsZero(){return i.Open3dMath.EpsilonEquals(this.X,0)&&i.Open3dMath.EpsilonEquals(this.Y,0)&&i.Open3dMath.EpsilonEquals(this.Z,0)}get Length(){return Math.hypot(this.X,this.Y,this.Z)}static Add(t,e){return new a(t.X+e.X,t.Y+e.Y,t.Z+e.Z)}static AddToPoint(t,e){return new s.Point3d(t.X+e.X,t.Y+e.Y,t.Z+e.Z)}Add(t){return a.Add(this,t)}AddToPoint(t){return a.AddToPoint(this,t)}static Subtract(t,e){return new a(t.X-e.X,t.Y-e.Y,t.Z-e.Z)}Subtract(t){return a.Subtract(this,t)}static Multiply(t,e){return new a(t.X*e,t.Y*e,t.Z*e)}Multiply(t){return a.Multiply(this,t)}static Divide(t,e){if(0===e)throw new Error("Division by zero");const r=1/e;return new a(t.X*r,t.Y*r,t.Z*r)}Divide(t){return a.Divide(this,t)}static Interpolate(t,e,r){return new a(t.X+(e.X-t.X)*r,t.Y+(e.Y-t.Y)*r,t.Z+(e.Z-t.Z)*r)}static DotProduct(t,e){return t.X*e.X+t.Y*e.Y+t.Z*e.Z}DotProduct(t){return a.DotProduct(this,t)}static CrossProduct(t,e){return new a(t.Y*e.Z-e.Y*t.Z,t.Z*e.X-e.Z*t.X,t.X*e.Y-e.X*t.Y)}CrossProduct(t){return a.CrossProduct(this,t)}static Distance(t,e){return e.Subtract(t).Length}DistanceTo(t){return a.Distance(this,t)}static Equals(t,e){return i.Open3dMath.EpsilonEquals(t.X,e.X)&&i.Open3dMath.EpsilonEquals(t.Y,e.Y)&&i.Open3dMath.EpsilonEquals(t.Z,e.Z)}Equals(t){return a.Equals(this,t)}static VectorAngle(t,e){if(t.IsZero||e.IsZero)throw new Error("Cannot compute angle of zero-length vector.");let r=a.DotProduct(t,e)/(t.Length*e.Length);return r=i.Open3dMath.Clamp(r,-1,1),Math.acos(r)}VectorAngle(t){return a.VectorAngle(this,t)}static Reverse(t){return new a(-t.X,-t.Y,-t.Z)}Reverse(){return a.Reverse(this)}static Unitize(t){var e=t.Length;if(0===e)throw new Error("Cannot unitize a zero-length vector.");return new a(t.X/e,t.Y/e,t.Z/e)}Unitize(){return a.Unitize(this)}IsTiny(t=n.Open3d.EPSILON){return Math.abs(this.X)<t&&Math.abs(this.Y)<t&&Math.abs(this.Z)<t}static IsParallel(t,e){if(t.IsZero||e.IsZero)return n.Open3d.ParallelIndicator.Parallel;const r=a.VectorAngle(t,e);return i.Open3dMath.EpsilonEquals(r,0,n.Open3d.ANGLE_EPSILON)?n.Open3d.ParallelIndicator.Parallel:i.Open3dMath.EpsilonEquals(r,Math.PI,n.Open3d.ANGLE_EPSILON)?n.Open3d.ParallelIndicator.AntiParallel:n.Open3d.ParallelIndicator.NotParallel}IsParallelTo(t){return a.IsParallel(this,t)}static IsPerpendicular(t,e){if(t.IsZero||e.IsZero)return!0;const r=a.VectorAngle(t,e);return!!i.Open3dMath.EpsilonEquals(r,Math.PI/2,n.Open3d.ANGLE_EPSILON)||!!i.Open3dMath.EpsilonEquals(r,-Math.PI/2,n.Open3d.ANGLE_EPSILON)}IsPerpendicularTo(t){return a.IsPerpendicular(this,t)}VectorRotate(t,e){const r=o.Transform.RotateAtOrigin(t,e);return this.Transform(r)}GetPerpendicularVector(){let t,e,r,n,i;r=2,Math.abs(this.Y)>Math.abs(this.X)?Math.abs(this.Z)>Math.abs(this.Y)?(t=2,e=1,r=0,n=this.Z,i=-this.Y):Math.abs(this.Z)>=Math.abs(this.X)?(t=1,e=2,r=0,n=this.Y,i=-this.Z):(t=1,e=0,r=2,n=this.Y,i=-this.X):Math.abs(this.Z)>Math.abs(this.X)?(t=2,e=0,r=1,n=this.Z,i=-this.X):Math.abs(this.Z)>Math.abs(this.Y)?(t=0,e=2,r=1,n=this.X,i=-this.Z):(t=0,e=1,r=2,n=this.X,i=-this.Y);let s=[0,0,0];return s[t]=i,s[e]=n,s[r]=0,new a(s[0],s[1],s[2]).Unitize()}Transform(t){let e,r,n;const i=t.M;return i[3]=0,i[7]=0,i[11]=0,e=i[0]*this.X+i[1]*this.Y+i[2]*this.Z+i[3],r=i[4]*this.X+i[5]*this.Y+i[6]*this.Z+i[7],n=i[8]*this.X+i[9]*this.Y+i[10]*this.Z+i[11],new a(e,r,n)}toString(){return`Vector3d [${this.X}, ${this.Y}, ${this.Z}]`}}e.Vector3d=a,a.XAxis=new a(1,0,0),a.YAxis=new a(0,1,0),a.ZAxis=new a(0,0,1),a.Zero=new a(0,0,0)}},e={};function r(n){var i=e[n];if(void 0!==i)return i.exports;var s=e[n]={exports:{}};return t[n](s,s.exports,r),s.exports}var n={};return(()=>{var t=n;Object.defineProperty(t,"__esModule",{value:!0}),t.Open3d=t.Open3dMath=t.IntersectionEvent=t.Intersection=t.Transform=t.Plane=t.Polyline=t.Line=t.Point3d=t.Vector3d=void 0;var e=r(226);Object.defineProperty(t,"Vector3d",{enumerable:!0,get:function(){return e.Vector3d}});var i=r(35);Object.defineProperty(t,"Point3d",{enumerable:!0,get:function(){return i.Point3d}});var s=r(582);Object.defineProperty(t,"Line",{enumerable:!0,get:function(){return s.Line}});var o=r(465);Object.defineProperty(t,"Polyline",{enumerable:!0,get:function(){return o.Polyline}});var a=r(614);Object.defineProperty(t,"Plane",{enumerable:!0,get:function(){return a.Plane}});var l=r(950);Object.defineProperty(t,"Transform",{enumerable:!0,get:function(){return l.Transform}});var u=r(387);Object.defineProperty(t,"Intersection",{enumerable:!0,get:function(){return u.Intersection}});var h=r(975);Object.defineProperty(t,"IntersectionEvent",{enumerable:!0,get:function(){return h.IntersectionEvent}});var c=r(561);Object.defineProperty(t,"Open3dMath",{enumerable:!0,get:function(){return c.Open3dMath}});var d=r(653);Object.defineProperty(t,"Open3d",{enumerable:!0,get:function(){return d.Open3d}})})(),n})()));