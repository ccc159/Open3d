!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.Open3d=e():t.Open3d=e()}(this,(()=>(()=>{"use strict";var t={465:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Intersection=void 0;const n=r(582),i=r(653),s=r(561),o=r(614),a=r(35);class l{constructor(){throw new Error("Cannot initialize an intersection instance.")}static LineLine(t,e,r=!1,n=i.Open3d.EPSILON){if(!t.IsValid||!e.IsValid)return null;const o=t.From,l=t.To,u=e.From,c=e.To,h=o.SubtractPoint(u),d=c.SubtractPoint(u),P=l.SubtractPoint(o),p=h.X*d.X+h.Y*d.Y+h.Z*d.Z,Z=d.X*P.X+d.Y*P.Y+d.Z*P.Z,X=h.X*P.X+h.Y*P.Y+h.Z*P.Z,Y=d.X*d.X+d.Y*d.Y+d.Z*d.Z,m=(P.X*P.X+P.Y*P.Y+P.Z*P.Z)*Y-Z*Z;if(s.Open3dMath.EpsilonEquals(m,0))return null;const O=(p*Z-X*Y)/m,M=(p+Z*O)/Y,A=new a.Point3d(o.X+O*P.X,o.Y+O*P.Y,o.Z+O*P.Z),f=new a.Point3d(u.X+M*d.X,u.Y+M*d.Y,u.Z+M*d.Z);if(A.DistanceTo(f)>n)return null;const g=A.AddPoint(f).Divide(2);if(!r)return g;const E=t.ClosestParameter(g,!1),w=e.ClosestParameter(g,!1);return E>=0&&E<=1&&w>=0&&w<=1?g:null}static LinePlane(t,e,r=!1){const n=t.From.SubtractPoint(e.Origin).DotProduct(e.Normal),i=t.UnitDirection.DotProduct(e.Normal);if(s.Open3dMath.EpsilonEquals(i,0))return null;const o=-n/i;return r&&(o<0||o>t.Length)?null:t.From.Add(t.UnitDirection.Multiply(o))}static PlanePlane(t,e){if(t.Normal.IsParallelTo(e.Normal))return null;const r=e.Normal.CrossProduct(t.Normal),i=t.Origin.AddPoint(e.Origin).Multiply(.5),s=o.Plane.CreateFromNormal(i,r),a=l.PlanePlanePlane(t,e,s);return null==a?null:new n.Line(a,a.Add(s.Normal))}static PlanePlanePlane(t,e,r){const n=t.Equation,i=e.Equation,o=r.Equation,l=[n[0],n[1],n[2],i[0],i[1],i[2],o[0],o[1],o[2]],u=[-n[3],-i[3],-o[3]],[c,h,d,P,p,Z,X,Y,m]=l,O=c*(p*m-Z*Y)-h*(P*m-Z*X)+d*(P*Y-p*X);if(s.Open3dMath.EpsilonEquals(O,0))return null;const M=1/O,A=M*(p*m-Z*Y)*u[0]+M*(d*Y-h*m)*u[1]+M*(h*Z-d*p)*u[2],f=M*(Z*X-P*m)*u[0]+M*(c*m-d*X)*u[1]+M*(d*P-c*Z)*u[2],g=M*(P*Y-p*X)*u[0]+M*(h*X-c*Y)*u[1]+M*(c*p-h*P)*u[2];return new a.Point3d(A,f,g)}}e.Intersection=l},582:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Line=void 0;const n=r(561);class i{constructor(t,e){this.From=t,this.To=e}get IsValid(){return!this.From.Equals(this.To)}get Direction(){if(!this.IsValid)throw new Error("Cannot get direction of an invalid line.");return this.To.SubtractPoint(this.From)}get UnitDirection(){return this.Direction.Unitize()}get Length(){return this.To.DistanceTo(this.From)}set Length(t){let e=this.UnitDirection;t<0&&(e=e.Reverse()),this.To=this.From.Add(e.Multiply(Math.abs(t)))}Clone(){return new i(this.From,this.To)}PointAt(t){if(!this.IsValid)throw new Error("Cannot evaluate an invalid line.");return this.Direction.Multiply(t).AddToPoint(this.From)}PointAtLength(t){if(!this.IsValid)throw new Error("Cannot evaluate an invalid line.");return this.UnitDirection.Multiply(t).AddToPoint(this.From)}ClosestParameter(t,e=!1){if(!this.IsValid)throw new Error("Invalid line does not have a closest point.");const r=t.SubtractPoint(this.From),i=this.To.SubtractPoint(this.From),s=i.DotProduct(i);let o=i.DotProduct(r)/s;return e&&(o=n.Open3dMath.Clamp(o,0,1)),o}ClosestPoint(t,e=!1){const r=this.ClosestParameter(t,e);return this.PointAt(r)}DistanceTo(t,e=!1){return this.ClosestPoint(t,e).DistanceTo(t)}Equals(t){return this.From.Equals(t.From)&&this.To.Equals(t.To)}Extend(t,e){if(!this.IsValid)throw new Error("Cannot extend an invalid line.");const r=this.UnitDirection.Multiply(-t).AddToPoint(this.From),n=this.UnitDirection.Multiply(e).AddToPoint(this.To);return new i(r,n)}Flip(){return new i(this.To,this.From)}Transform(t){const e=this.From.Transform(t),r=this.To.Transform(t);return new i(e,r)}}e.Line=i},653:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Open3d=void 0,function(t){let e;!function(t){t[t.Parallel=1]="Parallel",t[t.NotParallel=0]="NotParallel",t[t.AntiParallel=-1]="AntiParallel"}(e=t.ParallelIndicator||(t.ParallelIndicator={})),t.EPSILON=1e-6,t.ANGLE_EPSILON=.001}(e.Open3d||(e.Open3d={}))},561:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Open3dMath=void 0;const n=r(653);class i{static Clamp(t,e,r){if(e>r){const t=e;e=r,r=t}return Math.min(Math.max(t,e),r)}static ToDegrees(t){return 180*t/Math.PI}static ToRadians(t){return t*Math.PI/180}}e.Open3dMath=i,i.EpsilonEquals=(t,e,r=n.Open3d.EPSILON)=>Math.abs(t-e)<r},614:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Plane=void 0;const n=r(582),i=r(226),s=r(35);class o{constructor(t,e,r){e=e.Unitize(),r=r.Unitize();const n=e.CrossProduct(r).Unitize();r=n.CrossProduct(e).Unitize(),this.Origin=t,this.XAxis=e,this.YAxis=r,this.ZAxis=n}get Normal(){return this.ZAxis.Unitize()}get XAxisLine(){return new n.Line(this.Origin,this.Origin.Add(this.XAxis))}get YAxisLine(){return new n.Line(this.Origin,this.Origin.Add(this.YAxis))}get ZAxisLine(){return new n.Line(this.Origin,this.Origin.Add(this.ZAxis))}get Equation(){const{X:t,Y:e,Z:r}=this.Normal;return[t,e,r,-t*this.Origin.X-e*this.Origin.Y-r*this.Origin.Z]}static get PlaneXY(){return new o(s.Point3d.Origin,i.Vector3d.XAxis,i.Vector3d.YAxis)}static get PlaneZX(){return new o(s.Point3d.Origin,i.Vector3d.ZAxis,i.Vector3d.XAxis)}static get PlaneYZ(){return new o(s.Point3d.Origin,i.Vector3d.YAxis,i.Vector3d.ZAxis)}PointAt(t,e){return this.Origin.Add(this.XAxis.Multiply(t)).Add(this.YAxis.Multiply(e))}ClosestParameter(t){return[this.XAxisLine.ClosestParameter(t),this.YAxisLine.ClosestParameter(t)]}ClosestPoint(t){return this.PointAt(...this.ClosestParameter(t))}DistanceTo(t){const e=t.SubtractPoint(this.Origin),r=t.DistanceTo(this.ClosestPoint(t));return e.DotProduct(this.ZAxis)>0?r:-r}Clone(){return new o(this.Origin,this.XAxis,this.YAxis)}Flip(){return new o(this.Origin,this.YAxis,this.XAxis)}IsPointCoplanar(t){return this.ClosestPoint(t).Equals(t)}IsLineCoplanar(t){return this.ClosestPoint(t.From).Equals(t.From)&&this.ClosestPoint(t.To).Equals(t.To)}static CreateFromNormal(t,e){const r=e.Unitize(),n=e.GetPerpendicularVector(),i=r.CrossProduct(n).Unitize();return new o(t,n,i)}static CreateFromFrame(t,e,r){return new o(t,e,r)}Transform(t){const e=this.Origin.Transform(t),r=this.XAxis.Transform(t),n=this.YAxis.Transform(t);return new o(e,r,n)}}e.Plane=o},35:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Point3d=void 0;const n=r(561),i=r(226);class s{constructor(t,e,r){this.X=t,this.Y=e,this.Z=r}static CreateFromVector(t){return new s(t.X,t.Y,t.Z)}static CreateFromPoint3d(t){return new s(t.X,t.Y,t.Z)}static get Origin(){return new s(0,0,0)}static Add(t,e){return new s(t.X+e.X,t.Y+e.Y,t.Z+e.Z)}static AddPoint(t,e){return new s(t.X+e.X,t.Y+e.Y,t.Z+e.Z)}Add(t){return s.Add(this,t)}AddPoint(t){return s.AddPoint(this,t)}static Subtract(t,e){return new s(t.X-e.X,t.Y-e.Y,t.Z-e.Z)}static SubtractPoint(t,e){return new i.Vector3d(t.X-e.X,t.Y-e.Y,t.Z-e.Z)}Subtract(t){return s.Subtract(this,t)}SubtractPoint(t){return s.SubtractPoint(this,t)}static Multiply(t,e){return new s(t.X*e,t.Y*e,t.Z*e)}Multiply(t){return s.Multiply(this,t)}static Divide(t,e){if(0===e)throw new Error("Division by zero");const r=1/e;return new s(t.X*r,t.Y*r,t.Z*r)}Divide(t){return s.Divide(this,t)}static Interpolate(t,e,r){return new s(t.X+(e.X-t.X)*r,t.Y+(e.Y-t.Y)*r,t.Z+(e.Z-t.Z)*r)}static Distance(t,e){return Math.hypot(t.X-e.X,t.Y-e.Y,t.Z-e.Z)}DistanceTo(t){return s.Distance(this,t)}static Equals(t,e){return n.Open3dMath.EpsilonEquals(t.X,e.X)&&n.Open3dMath.EpsilonEquals(t.Y,e.Y)&&n.Open3dMath.EpsilonEquals(t.Z,e.Z)}Equals(t){return s.Equals(this,t)}Transform(t){let e,r,n;const i=t.M;return e=i[0]*this.X+i[1]*this.Y+i[2]*this.Z+i[3],r=i[4]*this.X+i[5]*this.Y+i[6]*this.Z+i[7],n=i[8]*this.X+i[9]*this.Y+i[10]*this.Z+i[11],new s(e,r,n)}toString(){return`Point3d [${this.X}, ${this.Y}, ${this.Z}]`}}e.Point3d=s},950:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Transform=void 0;const n=r(561),i=r(35),s=r(226);class o{constructor(t){this.m=t}get Determinant(){const[t,e,r,n,i,s,o,a,l,u,c,h,d,P,p,Z]=this.m;return n*(+d*u*o-l*P*o-d*s*c+i*P*c+l*s*p-i*u*p)+a*(+t*u*p-t*P*c+d*e*c-l*e*p+l*P*r-d*u*r)+h*(+t*P*o-t*s*p-d*e*o+i*e*p+d*s*r-i*P*r)+Z*(-l*s*r-t*u*o+t*s*c+l*e*o-i*e*c+i*u*r)}get M(){return this.ToArray()}static get Identity(){return new o([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}get IsIdentity(){return this.Equals(o.Identity)}static get ZeroTransformation(){return new o([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1])}get IsZeroTransformation(){return this.Equals(o.ZeroTransformation)}Equals(t){const e=this.M,r=t.M;for(let t=0;t<16;t++)if(!n.Open3dMath.EpsilonEquals(e[t],r[t]))return!1;return!0}Clone(){return new o(this.M)}ToArray(){return[...this.m]}static MultiplyMatrix(t,e){const r=t.m,n=e.m,[i,s,a,l,u,c,h,d,P,p,Z,X,Y,m,O,M]=r,[A,f,g,E,w,T,b,v,I,x,y,C,V,D,L,q]=n;return new o([i*A+s*w+a*I+l*V,i*f+s*T+a*x+l*D,i*g+s*b+a*y+l*L,i*E+s*v+a*C+l*q,u*A+c*w+h*I+d*V,u*f+c*T+h*x+d*D,u*g+c*b+h*y+d*L,u*E+c*v+h*C+d*q,P*A+p*w+Z*I+X*V,P*f+p*T+Z*x+X*D,P*g+p*b+Z*y+X*L,P*E+p*v+Z*C+X*q,Y*A+m*w+O*I+M*V,Y*f+m*T+O*x+M*D,Y*g+m*b+O*y+M*L,Y*E+m*v+O*C+M*q])}MultiplyMatrix(t){return o.MultiplyMatrix(this,t)}static MultiplyScalar(t,e){const r=t.M;for(let t=0;t<16;t++)r[t]*=e;return new o(r)}MultiplyScalar(t){return o.MultiplyScalar(this,t)}static Rotation(t,e=s.Vector3d.ZAxis,r=i.Point3d.Origin){const n=s.Vector3d.CreateFromPoint3d(r),a=o.Translation(n.Reverse()),l=o.RotateAtOrigin(t,e),u=o.Translation(n);return o.CombineTransforms([a,l,u])}static RotateAtOrigin(t,e){const r=Math.cos(t),n=Math.sin(t),i=1-r;if(e.IsZero)throw new Error("Rotation axis should not be zero vector.");const s=(e=e.Unitize()).X,a=e.Y,l=e.Z,u=i*s,c=i*a;return new o([u*s+r,u*a-n*l,u*l+n*a,0,u*a+n*l,c*a+r,c*l-n*s,0,u*l-n*a,c*l+n*s,i*l*l+r,0,0,0,0,1])}static RotationX(t){return o.Rotation(t,s.Vector3d.XAxis)}static RotationY(t){return o.Rotation(t,s.Vector3d.YAxis)}static RotationZ(t){return o.Rotation(t,s.Vector3d.ZAxis)}static RotationZYX(t,e,r){const n=o.RotationZ(t),i=o.RotationY(e),s=o.RotationX(r);return o.CombineTransforms([s,i,n])}static Translation(t){return new o([1,0,0,t.X,0,1,0,t.Y,0,0,1,t.Z,0,0,0,1])}static Scale(t,e){const r=s.Vector3d.CreateFromPoint3d(t),n=o.Translation(r.Reverse()),i=o.ScaleAtOrigin(e,e,e),a=o.Translation(r);return o.CombineTransforms([n,i,a])}static CombineTransforms(t){const e=[...t];e.reverse();let r=o.Identity;for(let t=0;t<e.length;t++)r=r.MultiplyMatrix(e[t]);return r}static ScaleAtOrigin(t,e,r){return new o([t,0,0,0,0,e,0,0,0,0,r,0,0,0,0,1])}static PlanarProjection(t){let e=t.XAxis,r=t.YAxis,n=t.Origin;const i=e.X*e.X+r.X*r.X,s=e.X*e.Y+r.X*r.Y,a=e.X*e.Z+r.X*r.Z,l=e.Y*e.X+r.Y*r.X,u=e.Y*e.Y+r.Y*r.Y,c=e.Y*e.Z+r.Y*r.Z,h=e.Z*e.X+r.Z*r.X,d=e.Z*e.Y+r.Z*r.Y,P=e.Z*e.Z+r.Z*r.Z,p=n.X-i*n.X+s*n.Y+a*n.Z,Z=n.Y-l*n.X+u*n.Y+c*n.Z,X=n.Z-h*n.X+d*n.Y+P*n.Z;return new o([i,s,a,p,l,u,c,Z,h,d,P,X,0,0,0,1])}static Mirror(t){const e=t.Equation,r=t.Normal,n=r.Multiply(-2*e[3]),i=1-2*r.X*r.X,s=-2*r.X*r.Y,a=-2*r.X*r.Z,l=n.X,u=-2*r.Y*r.X,c=1-2*r.Y*r.Y,h=-2*r.Y*r.Z,d=n.Y,P=-2*r.Z*r.X,p=-2*r.Z*r.Y,Z=1-2*r.Z*r.Z,X=n.Z;return new o([i,s,a,l,u,c,h,d,P,p,Z,X,0,0,0,1])}static VectorToVector(t,e){const r=e.CrossProduct(t);let n=s.Vector3d.VectorAngle(t,e);return o.RotateAtOrigin(-n,r)}static PlaneToPlane(t,e){const r=o.Translation(i.Point3d.Origin.SubtractPoint(t.Origin)),n=o.VectorToVector(t.XAxis,e.XAxis),a=t.YAxis.Transform(n),l=o.VectorToVector(a,e.YAxis),u=o.Translation(s.Vector3d.CreateFromPoint3d(e.Origin));return o.CombineTransforms([r,n,l,u])}Transpose(){const t=this.M;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,new o(t)}TryGetInverse(){const t=this.M,[e,r,n,i,s,a,l,u,c,h,d,P,p,Z,X,Y]=this.m,m=h*X*u-Z*d*u+Z*l*P-a*X*P-h*l*Y+a*d*Y,O=p*d*u-c*X*u-p*l*P+s*X*P+c*l*Y-s*d*Y,M=c*Z*u-p*h*u+p*a*P-s*Z*P-c*a*Y+s*h*Y,A=p*h*l-c*Z*l-p*a*d+s*Z*d+c*a*X-s*h*X,f=e*m+r*O+n*M+i*A;if(0===f)return null;const g=1/f;return t[0]=m*g,t[1]=(Z*d*i-h*X*i-Z*n*P+r*X*P+h*n*Y-r*d*Y)*g,t[2]=(a*X*i-Z*l*i+Z*n*u-r*X*u-a*n*Y+r*l*Y)*g,t[3]=(h*l*i-a*d*i-h*n*u+r*d*u+a*n*P-r*l*P)*g,t[4]=O*g,t[5]=(c*X*i-p*d*i+p*n*P-e*X*P-c*n*Y+e*d*Y)*g,t[6]=(p*l*i-s*X*i-p*n*u+e*X*u+s*n*Y-e*l*Y)*g,t[7]=(s*d*i-c*l*i+c*n*u-e*d*u-s*n*P+e*l*P)*g,t[8]=M*g,t[9]=(p*h*i-c*Z*i-p*r*P+e*Z*P+c*r*Y-e*h*Y)*g,t[10]=(s*Z*i-p*a*i+p*r*u-e*Z*u-s*r*Y+e*a*Y)*g,t[11]=(c*a*i-s*h*i-c*r*u+e*h*u+s*r*P-e*a*P)*g,t[12]=A*g,t[13]=(c*Z*n-p*h*n+p*r*d-e*Z*d-c*r*X+e*h*X)*g,t[14]=(p*a*n-s*Z*n-p*r*l+e*Z*l+s*r*X-e*a*X)*g,t[15]=(s*h*n-c*a*n+c*r*l-e*h*l-s*r*d+e*a*d)*g,new o(t)}toString(){const[t,e,r,n,i,s,o,a,l,u,c,h,d,P,p,Z]=this.m;return`R0=(${t}, ${i}, ${l}, ${d}), R1=(${e}, ${s}, ${u}, ${P}), R2=(${r}, ${o}, ${c}, ${p}), R3=(${n}, ${a}, ${h}, ${Z})`}}e.Transform=o},226:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Vector3d=void 0;const n=r(653),i=r(561),s=r(35),o=r(950);class a{constructor(t,e,r){this.X=t,this.Y=e,this.Z=r}static CreateFromVector(t){return new a(t.X,t.Y,t.Z)}static CreateFromPoint3d(t){return new a(t.X,t.Y,t.Z)}get IsUnitVector(){return i.Open3dMath.EpsilonEquals(this.Length,1)}get IsZero(){return i.Open3dMath.EpsilonEquals(this.X,0)&&i.Open3dMath.EpsilonEquals(this.Y,0)&&i.Open3dMath.EpsilonEquals(this.Z,0)}get Length(){return Math.hypot(this.X,this.Y,this.Z)}static Add(t,e){return new a(t.X+e.X,t.Y+e.Y,t.Z+e.Z)}static AddToPoint(t,e){return new s.Point3d(t.X+e.X,t.Y+e.Y,t.Z+e.Z)}Add(t){return a.Add(this,t)}AddToPoint(t){return a.AddToPoint(this,t)}static Subtract(t,e){return new a(t.X-e.X,t.Y-e.Y,t.Z-e.Z)}Subtract(t){return a.Subtract(this,t)}static Multiply(t,e){return new a(t.X*e,t.Y*e,t.Z*e)}Multiply(t){return a.Multiply(this,t)}static Divide(t,e){if(0===e)throw new Error("Division by zero");const r=1/e;return new a(t.X*r,t.Y*r,t.Z*r)}Divide(t){return a.Divide(this,t)}static Interpolate(t,e,r){return new a(t.X+(e.X-t.X)*r,t.Y+(e.Y-t.Y)*r,t.Z+(e.Z-t.Z)*r)}static DotProduct(t,e){return t.X*e.X+t.Y*e.Y+t.Z*e.Z}DotProduct(t){return a.DotProduct(this,t)}static CrossProduct(t,e){return new a(t.Y*e.Z-e.Y*t.Z,t.Z*e.X-e.Z*t.X,t.X*e.Y-e.X*t.Y)}CrossProduct(t){return a.CrossProduct(this,t)}static Distance(t,e){return e.Subtract(t).Length}DistanceTo(t){return a.Distance(this,t)}static Equals(t,e){return i.Open3dMath.EpsilonEquals(t.X,e.X)&&i.Open3dMath.EpsilonEquals(t.Y,e.Y)&&i.Open3dMath.EpsilonEquals(t.Z,e.Z)}Equals(t){return a.Equals(this,t)}static VectorAngle(t,e){if(t.IsZero||e.IsZero)throw new Error("Cannot compute angle of zero-length vector.");let r=a.DotProduct(t,e)/(t.Length*e.Length);return r=i.Open3dMath.Clamp(r,-1,1),Math.acos(r)}VectorAngle(t){return a.VectorAngle(this,t)}static Reverse(t){return new a(-t.X,-t.Y,-t.Z)}Reverse(){return a.Reverse(this)}static Unitize(t){var e=t.Length;if(0===e)throw new Error("Cannot unitize a zero-length vector.");return new a(t.X/e,t.Y/e,t.Z/e)}Unitize(){return a.Unitize(this)}static IsParallel(t,e){if(t.IsZero||e.IsZero)return n.Open3d.ParallelIndicator.Parallel;const r=a.VectorAngle(t,e);return i.Open3dMath.EpsilonEquals(r,0,n.Open3d.ANGLE_EPSILON)?n.Open3d.ParallelIndicator.Parallel:i.Open3dMath.EpsilonEquals(r,Math.PI,n.Open3d.ANGLE_EPSILON)?n.Open3d.ParallelIndicator.AntiParallel:n.Open3d.ParallelIndicator.NotParallel}IsParallelTo(t){return a.IsParallel(this,t)}static IsPerpendicular(t,e){if(t.IsZero||e.IsZero)return!0;const r=a.VectorAngle(t,e);return!!i.Open3dMath.EpsilonEquals(r,Math.PI/2,n.Open3d.ANGLE_EPSILON)||!!i.Open3dMath.EpsilonEquals(r,-Math.PI/2,n.Open3d.ANGLE_EPSILON)}IsPerpendicularTo(t){return a.IsPerpendicular(this,t)}VectorRotate(t,e){const r=o.Transform.RotateAtOrigin(t,e);return this.Transform(r)}GetPerpendicularVector(){let t,e,r,n,i;r=2,Math.abs(this.Y)>Math.abs(this.X)?Math.abs(this.Z)>Math.abs(this.Y)?(t=2,e=1,r=0,n=this.Z,i=-this.Y):Math.abs(this.Z)>=Math.abs(this.X)?(t=1,e=2,r=0,n=this.Y,i=-this.Z):(t=1,e=0,r=2,n=this.Y,i=-this.X):Math.abs(this.Z)>Math.abs(this.X)?(t=2,e=0,r=1,n=this.Z,i=-this.X):Math.abs(this.Z)>Math.abs(this.Y)?(t=0,e=2,r=1,n=this.X,i=-this.Z):(t=0,e=1,r=2,n=this.X,i=-this.Y);let s=[0,0,0];return s[t]=i,s[e]=n,s[r]=0,new a(s[0],s[1],s[2]).Unitize()}Transform(t){let e,r,n;const i=t.M;return i[3]=0,i[7]=0,i[11]=0,e=i[0]*this.X+i[1]*this.Y+i[2]*this.Z+i[3],r=i[4]*this.X+i[5]*this.Y+i[6]*this.Z+i[7],n=i[8]*this.X+i[9]*this.Y+i[10]*this.Z+i[11],new a(e,r,n)}toString(){return`Vector3d [${this.X}, ${this.Y}, ${this.Z}]`}}e.Vector3d=a,a.XAxis=new a(1,0,0),a.YAxis=new a(0,1,0),a.ZAxis=new a(0,0,1),a.Zero=new a(0,0,0)}},e={};function r(n){var i=e[n];if(void 0!==i)return i.exports;var s=e[n]={exports:{}};return t[n](s,s.exports,r),s.exports}var n={};return(()=>{var t=n;Object.defineProperty(t,"__esModule",{value:!0}),t.Open3d=t.Open3dMath=t.Intersection=t.Transform=t.Plane=t.Line=t.Point3d=t.Vector3d=void 0;var e=r(226);Object.defineProperty(t,"Vector3d",{enumerable:!0,get:function(){return e.Vector3d}});var i=r(35);Object.defineProperty(t,"Point3d",{enumerable:!0,get:function(){return i.Point3d}});var s=r(582);Object.defineProperty(t,"Line",{enumerable:!0,get:function(){return s.Line}});var o=r(614);Object.defineProperty(t,"Plane",{enumerable:!0,get:function(){return o.Plane}});var a=r(950);Object.defineProperty(t,"Transform",{enumerable:!0,get:function(){return a.Transform}});var l=r(465);Object.defineProperty(t,"Intersection",{enumerable:!0,get:function(){return l.Intersection}});var u=r(561);Object.defineProperty(t,"Open3dMath",{enumerable:!0,get:function(){return u.Open3dMath}});var c=r(653);Object.defineProperty(t,"Open3d",{enumerable:!0,get:function(){return c.Open3d}})})(),n})()));