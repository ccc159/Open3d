!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.Open3d=e():t.Open3d=e()}(this,(()=>(()=>{"use strict";var t={465:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Intersection=void 0;const r=n(323),i=n(582),o=n(653),s=n(561),a=n(614),l=n(35);class c{constructor(){throw new Error("Cannot initialize an intersection instance.")}static LineLineTParameters(t,e){const n=t.From.SubtractPoint(e.From),r=e.Direction,i=t.Direction,o=n.DotProduct(r),a=r.DotProduct(i),l=n.DotProduct(i),c=r.DotProduct(r),u=i.DotProduct(i)*c-a*a,h=o*a-l*c;if(s.Open3dMath.EpsilonEquals(u,0))return null;const d=h/u;return[d,(o+a*d)/c]}static LineLine(t,e,n=!1,r=o.Open3d.EPSILON){const i=c.CrossingLineLine(t,e,n,r);return i?i.PointA.AddPoint(i.PointB).Multiply(.5):null}static CrossingLineLine(t,e,n=!1,i=1/0){if(!t.IsValid||!e.IsValid)return null;const o=c.LineLineTParameters(t,e);if(!o)return null;const[s,a]=o,l=t.PointAt(s),u=e.PointAt(a),h=l.DistanceTo(u);return n&&(s<0||s>1||a<0||a>1)||h>i?null:new r.IntersectionEvent(s,a,l,u)}static LinePlane(t,e,n=!1){const r=t.From.SubtractPoint(e.Origin).DotProduct(e.Normal),i=t.UnitDirection.DotProduct(e.Normal);if(s.Open3dMath.EpsilonEquals(i,0))return null;const o=-r/i;return n&&(o<0||o>t.Length)?null:t.From.Add(t.UnitDirection.Multiply(o))}static PlanePlane(t,e){if(t.Normal.IsParallelTo(e.Normal))return null;const n=e.Normal.CrossProduct(t.Normal),r=t.Origin.AddPoint(e.Origin).Multiply(.5),o=a.Plane.CreateFromNormal(r,n),s=c.PlanePlanePlane(t,e,o);return null==s?null:new i.Line(s,s.Add(o.Normal))}static PlanePlanePlane(t,e,n){const r=t.Equation,i=e.Equation,o=n.Equation,a=[r[0],r[1],r[2],i[0],i[1],i[2],o[0],o[1],o[2]],c=[-r[3],-i[3],-o[3]],[u,h,d,P,p,m,Z,A,O]=a,X=u*(p*O-m*A)-h*(P*O-m*Z)+d*(P*A-p*Z);if(s.Open3dMath.EpsilonEquals(X,0))return null;const Y=1/X,f=Y*(p*O-m*A)*c[0]+Y*(d*A-h*O)*c[1]+Y*(h*m-d*p)*c[2],g=Y*(m*Z-P*O)*c[0]+Y*(u*O-d*Z)*c[1]+Y*(d*P-u*m)*c[2],M=Y*(P*A-p*Z)*c[0]+Y*(h*Z-u*A)*c[1]+Y*(u*p-h*P)*c[2];return new l.Point3d(f,g,M)}}e.Intersection=c},582:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Line=void 0;const r=n(465),i=n(653),o=n(561),s=n(614);class a{constructor(t,e){this.From=t,this.To=e}get IsValid(){return!this.From.Equals(this.To)}get Direction(){if(!this.IsValid)throw new Error("Cannot get direction of an invalid line.");return this.To.SubtractPoint(this.From)}get UnitDirection(){return this.Direction.Unitize()}get Length(){return this.To.DistanceTo(this.From)}set Length(t){let e=this.UnitDirection;t<0&&(e=e.Reverse()),this.To=this.From.Add(e.Multiply(Math.abs(t)))}Clone(){return new a(this.From,this.To)}PointAt(t){if(!this.IsValid)throw new Error("Cannot evaluate an invalid line.");return this.From.Add(this.Direction.Multiply(t))}PointAtLength(t){if(!this.IsValid)throw new Error("Cannot evaluate an invalid line.");return this.UnitDirection.Multiply(t).AddToPoint(this.From)}ClosestParameter(t,e=!1){if(!this.IsValid)throw new Error("Invalid line does not have a closest point.");const n=t.SubtractPoint(this.From),r=this.To.SubtractPoint(this.From),i=r.DotProduct(r);let s=r.DotProduct(n)/i;return e&&(s=o.Open3dMath.Clamp(s,0,1)),s}ClosestPoint(t,e=!1){const n=this.ClosestParameter(t,e);return this.PointAt(n)}DistanceTo(t,e=!1){return t instanceof a?a.LineLineDistance(this,t,e):t instanceof s.Plane?a.LinePlaneDistance(this,t,e):a.LinePointDistance(this,t,e)}Equals(t){return this.From.Equals(t.From)&&this.To.Equals(t.To)}IsParallelTo(t){return t instanceof a?this.Direction.IsParallelTo(t):t instanceof s.Plane?t.Normal.IsPerpendicularTo(this.Direction)?i.Open3d.ParallelIndicator.Parallel:i.Open3d.ParallelIndicator.NotParallel:t.IsParallelTo(this)}Extend(t,e){if(!this.IsValid)throw new Error("Cannot extend an invalid line.");const n=this.UnitDirection.Multiply(-t).AddToPoint(this.From),r=this.UnitDirection.Multiply(e).AddToPoint(this.To);return new a(n,r)}Flip(){return new a(this.To,this.From)}Transform(t){const e=this.From.Transform(t),n=this.To.Transform(t);return new a(e,n)}static CreateFromOriginAndDirection(t,e,n){return new a(t,t.Add(n?e.Unitize().Multiply(n):e))}static LinePointClosestParameter(t,e){if(!t.IsValid)return 0;const n=e.SubtractPoint(t.From),r=t.To.SubtractPoint(t.From),i=r.DotProduct(r);return r.DotProduct(n)/i}static LinePointClosestPoint(t,e,n){let r=a.LinePointClosestParameter(t,e);return n&&(r=o.Open3dMath.Clamp(r,0,1)),t.PointAt(r)}static LinePointDistance(t,e,n){const r=a.LinePointClosestPoint(t,e,n);return e.DistanceTo(r)}}e.Line=a,a.LineLineClosestPoints=(t,e,n)=>{const i=r.Intersection.CrossingLineLine(t,e,n);return i?[i.PointA,i.PointB]:null},a.LineLineDistance=(t,e,n)=>{const i=r.Intersection.CrossingLineLine(t,e,n);return i?i.PointA.DistanceTo(i.PointB):n?Math.min(a.LinePointDistance(e,t.From),a.LinePointDistance(e,t.To),a.LinePointDistance(t,e.From),a.LinePointDistance(t,e.To)):a.LinePointDistance(t,e.From)},a.LinePlaneDistance=(t,e,n)=>r.Intersection.LinePlane(t,e,n)?0:n?Math.min(e.DistanceTo(t.From),e.DistanceTo(t.To)):e.DistanceTo(t.From)},653:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Open3d=void 0,function(t){let e;!function(t){t[t.Parallel=1]="Parallel",t[t.NotParallel=0]="NotParallel",t[t.AntiParallel=-1]="AntiParallel"}(e=t.ParallelIndicator||(t.ParallelIndicator={})),t.EPSILON=1e-6,t.ANGLE_EPSILON=.001}(e.Open3d||(e.Open3d={}))},561:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Open3dMath=void 0;const r=n(653);class i{static Clamp(t,e,n){if(e>n){const t=e;e=n,n=t}return Math.min(Math.max(t,e),n)}static ToDegrees(t){return 180*t/Math.PI}static ToRadians(t){return t*Math.PI/180}}e.Open3dMath=i,i.EpsilonEquals=(t,e,n=r.Open3d.EPSILON)=>Math.abs(t-e)<n},614:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Plane=void 0;const r=n(582),i=n(226),o=n(35),s=n(465);class a{constructor(t,e,n){e=e.Unitize(),n=n.Unitize();const r=e.CrossProduct(n).Unitize();n=r.CrossProduct(e).Unitize(),this.Origin=t,this.XAxis=e,this.YAxis=n,this.ZAxis=r}get Normal(){return this.ZAxis.Unitize()}get XAxisLine(){return new r.Line(this.Origin,this.Origin.Add(this.XAxis))}get YAxisLine(){return new r.Line(this.Origin,this.Origin.Add(this.YAxis))}get ZAxisLine(){return new r.Line(this.Origin,this.Origin.Add(this.ZAxis))}get TPArameter(){return-this.Normal.DotProduct(i.Vector3d.CreateFromPoint3d(this.Origin))}get Equation(){const{X:t,Y:e,Z:n}=this.Normal;return[t,e,n,this.TPArameter]}static get PlaneXY(){return new a(o.Point3d.Origin,i.Vector3d.XAxis,i.Vector3d.YAxis)}static get PlaneZX(){return new a(o.Point3d.Origin,i.Vector3d.ZAxis,i.Vector3d.XAxis)}static get PlaneYZ(){return new a(o.Point3d.Origin,i.Vector3d.YAxis,i.Vector3d.ZAxis)}PointAt(t,e){return this.Origin.Add(this.XAxis.Multiply(t)).Add(this.YAxis.Multiply(e))}ClosestParameter(t){return[this.XAxisLine.ClosestParameter(t),this.YAxisLine.ClosestParameter(t)]}ClosestPoint(t){return this.PointAt(...this.ClosestParameter(t))}DistanceTo(t,e){return t instanceof r.Line?r.Line.LinePlaneDistance(t,this,e):t instanceof a?a.PlanePlaneDistance(this,t):a.PlanePointDistance(this,t)}SignedDistanceTo(t){const e=t.SubtractPoint(this.Origin),n=t.DistanceTo(this.ClosestPoint(t));return e.DotProduct(this.ZAxis)>0?n:-n}Clone(){return new a(this.Origin,this.XAxis,this.YAxis)}Flip(){return new a(this.Origin,this.YAxis,this.XAxis)}IsPointCoplanar(t){return this.ClosestPoint(t).Equals(t)}IsLineCoplanar(t){return this.ClosestPoint(t.From).Equals(t.From)&&this.ClosestPoint(t.To).Equals(t.To)}Transform(t){const e=this.Origin.Transform(t),n=this.XAxis.Transform(t),r=this.YAxis.Transform(t);return new a(e,n,r)}static CreateFromNormal(t,e){const n=e.Unitize(),r=e.GetPerpendicularVector(),i=n.CrossProduct(r).Unitize();return new a(t,r,i)}static CreateFromFrame(t,e,n){return new a(t,e,n)}static PlanePlaneDistance(t,e){return s.Intersection.PlanePlane(t,e)?0:a.PlanePointDistance(t,e.Origin)}static PlanePointDistance(t,e){return e.DistanceTo(t.ClosestPoint(e))}}e.Plane=a},35:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Point3d=void 0;const r=n(582),i=n(561),o=n(614),s=n(226);class a{constructor(t,e,n){this.X=t,this.Y=e,this.Z=n}static CreateFromVector(t){return new a(t.X,t.Y,t.Z)}static CreateFromPoint3d(t){return new a(t.X,t.Y,t.Z)}static get Origin(){return new a(0,0,0)}static Add(t,e){return new a(t.X+e.X,t.Y+e.Y,t.Z+e.Z)}static AddPoint(t,e){return new a(t.X+e.X,t.Y+e.Y,t.Z+e.Z)}Add(t){return a.Add(this,t)}AddPoint(t){return a.AddPoint(this,t)}static Subtract(t,e){return new a(t.X-e.X,t.Y-e.Y,t.Z-e.Z)}static SubtractPoint(t,e){return new s.Vector3d(t.X-e.X,t.Y-e.Y,t.Z-e.Z)}Subtract(t){return a.Subtract(this,t)}SubtractPoint(t){return a.SubtractPoint(this,t)}static Multiply(t,e){return new a(t.X*e,t.Y*e,t.Z*e)}Multiply(t){return a.Multiply(this,t)}static Divide(t,e){if(0===e)throw new Error("Division by zero");const n=1/e;return new a(t.X*n,t.Y*n,t.Z*n)}Divide(t){return a.Divide(this,t)}static Interpolate(t,e,n){return new a(t.X+(e.X-t.X)*n,t.Y+(e.Y-t.Y)*n,t.Z+(e.Z-t.Z)*n)}static Distance(t,e){return Math.hypot(t.X-e.X,t.Y-e.Y,t.Z-e.Z)}DistanceTo(t){return t instanceof r.Line?r.Line.LinePointDistance(t,this):t instanceof o.Plane?o.Plane.PlanePointDistance(t,this):a.Distance(this,t)}static Equals(t,e){return i.Open3dMath.EpsilonEquals(t.X,e.X)&&i.Open3dMath.EpsilonEquals(t.Y,e.Y)&&i.Open3dMath.EpsilonEquals(t.Z,e.Z)}Equals(t){return a.Equals(this,t)}Transform(t){let e,n,r;const i=t.M;return e=i[0]*this.X+i[1]*this.Y+i[2]*this.Z+i[3],n=i[4]*this.X+i[5]*this.Y+i[6]*this.Z+i[7],r=i[8]*this.X+i[9]*this.Y+i[10]*this.Z+i[11],new a(e,n,r)}toString(){return`Point3d [${this.X}, ${this.Y}, ${this.Z}]`}static Angle(t,e,n){const r=t.SubtractPoint(e),i=n.SubtractPoint(e);return s.Vector3d.VectorAngle(r,i)}static Angle2D(t,e,n){const r=t.SubtractPoint(e),i=n.SubtractPoint(e);return s.Vector3d.VectorAngle2D(r,i)}}e.Point3d=a},950:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Transform=void 0;const r=n(561),i=n(35),o=n(226);class s{constructor(t){this.m=t}get Determinant(){const[t,e,n,r,i,o,s,a,l,c,u,h,d,P,p,m]=this.m;return r*(+d*c*s-l*P*s-d*o*u+i*P*u+l*o*p-i*c*p)+a*(+t*c*p-t*P*u+d*e*u-l*e*p+l*P*n-d*c*n)+h*(+t*P*s-t*o*p-d*e*s+i*e*p+d*o*n-i*P*n)+m*(-l*o*n-t*c*s+t*o*u+l*e*s-i*e*u+i*c*n)}get M(){return this.ToArray()}static get Identity(){return new s([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}get IsIdentity(){return this.Equals(s.Identity)}static get ZeroTransformation(){return new s([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1])}get IsZeroTransformation(){return this.Equals(s.ZeroTransformation)}Equals(t){const e=this.M,n=t.M;for(let t=0;t<16;t++)if(!r.Open3dMath.EpsilonEquals(e[t],n[t]))return!1;return!0}Clone(){return new s(this.M)}ToArray(){return[...this.m]}static MultiplyMatrix(t,e){const n=t.m,r=e.m,[i,o,a,l,c,u,h,d,P,p,m,Z,A,O,X,Y]=n,[f,g,M,E,T,I,w,L,D,b,C,v,y,x,V,F]=r;return new s([i*f+o*T+a*D+l*y,i*g+o*I+a*b+l*x,i*M+o*w+a*C+l*V,i*E+o*L+a*v+l*F,c*f+u*T+h*D+d*y,c*g+u*I+h*b+d*x,c*M+u*w+h*C+d*V,c*E+u*L+h*v+d*F,P*f+p*T+m*D+Z*y,P*g+p*I+m*b+Z*x,P*M+p*w+m*C+Z*V,P*E+p*L+m*v+Z*F,A*f+O*T+X*D+Y*y,A*g+O*I+X*b+Y*x,A*M+O*w+X*C+Y*V,A*E+O*L+X*v+Y*F])}MultiplyMatrix(t){return s.MultiplyMatrix(this,t)}static MultiplyScalar(t,e){const n=t.M;for(let t=0;t<16;t++)n[t]*=e;return new s(n)}MultiplyScalar(t){return s.MultiplyScalar(this,t)}static Rotation(t,e=o.Vector3d.ZAxis,n=i.Point3d.Origin){const r=o.Vector3d.CreateFromPoint3d(n),a=s.Translation(r.Reverse()),l=s.RotateAtOrigin(t,e),c=s.Translation(r);return s.CombineTransforms([a,l,c])}static RotateAtOrigin(t,e){const n=Math.cos(t),r=Math.sin(t),i=1-n;if(e.IsZero)throw new Error("Rotation axis should not be zero vector.");const o=(e=e.Unitize()).X,a=e.Y,l=e.Z,c=i*o,u=i*a;return new s([c*o+n,c*a-r*l,c*l+r*a,0,c*a+r*l,u*a+n,u*l-r*o,0,c*l-r*a,u*l+r*o,i*l*l+n,0,0,0,0,1])}static RotationX(t){return s.Rotation(t,o.Vector3d.XAxis)}static RotationY(t){return s.Rotation(t,o.Vector3d.YAxis)}static RotationZ(t){return s.Rotation(t,o.Vector3d.ZAxis)}static RotationZYX(t,e,n){const r=s.RotationZ(t),i=s.RotationY(e),o=s.RotationX(n);return s.CombineTransforms([o,i,r])}static Translation(t){return new s([1,0,0,t.X,0,1,0,t.Y,0,0,1,t.Z,0,0,0,1])}static Scale(t,e){const n=o.Vector3d.CreateFromPoint3d(t),r=s.Translation(n.Reverse()),i=s.ScaleAtOrigin(e,e,e),a=s.Translation(n);return s.CombineTransforms([r,i,a])}static CombineTransforms(t){const e=[...t];e.reverse();let n=s.Identity;for(let t=0;t<e.length;t++)n=n.MultiplyMatrix(e[t]);return n}static ScaleAtOrigin(t,e,n){return new s([t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1])}static PlanarProjection(t){let e=t.XAxis,n=t.YAxis,r=t.Origin;const i=e.X*e.X+n.X*n.X,o=e.X*e.Y+n.X*n.Y,a=e.X*e.Z+n.X*n.Z,l=e.Y*e.X+n.Y*n.X,c=e.Y*e.Y+n.Y*n.Y,u=e.Y*e.Z+n.Y*n.Z,h=e.Z*e.X+n.Z*n.X,d=e.Z*e.Y+n.Z*n.Y,P=e.Z*e.Z+n.Z*n.Z,p=r.X-i*r.X+o*r.Y+a*r.Z,m=r.Y-l*r.X+c*r.Y+u*r.Z,Z=r.Z-h*r.X+d*r.Y+P*r.Z;return new s([i,o,a,p,l,c,u,m,h,d,P,Z,0,0,0,1])}static Mirror(t){const e=t.Equation,n=t.Normal,r=n.Multiply(-2*e[3]),i=1-2*n.X*n.X,o=-2*n.X*n.Y,a=-2*n.X*n.Z,l=r.X,c=-2*n.Y*n.X,u=1-2*n.Y*n.Y,h=-2*n.Y*n.Z,d=r.Y,P=-2*n.Z*n.X,p=-2*n.Z*n.Y,m=1-2*n.Z*n.Z,Z=r.Z;return new s([i,o,a,l,c,u,h,d,P,p,m,Z,0,0,0,1])}static VectorToVector(t,e){const n=e.CrossProduct(t);let r=o.Vector3d.VectorAngle(t,e);return s.RotateAtOrigin(-r,n)}static PlaneToPlane(t,e){const n=s.Translation(i.Point3d.Origin.SubtractPoint(t.Origin)),r=s.VectorToVector(t.XAxis,e.XAxis),a=t.YAxis.Transform(r),l=s.VectorToVector(a,e.YAxis),c=s.Translation(o.Vector3d.CreateFromPoint3d(e.Origin));return s.CombineTransforms([n,r,l,c])}Transpose(){const t=this.M;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,new s(t)}TryGetInverse(){const t=this.M,[e,n,r,i,o,a,l,c,u,h,d,P,p,m,Z,A]=this.m,O=h*Z*c-m*d*c+m*l*P-a*Z*P-h*l*A+a*d*A,X=p*d*c-u*Z*c-p*l*P+o*Z*P+u*l*A-o*d*A,Y=u*m*c-p*h*c+p*a*P-o*m*P-u*a*A+o*h*A,f=p*h*l-u*m*l-p*a*d+o*m*d+u*a*Z-o*h*Z,g=e*O+n*X+r*Y+i*f;if(0===g)return null;const M=1/g;return t[0]=O*M,t[1]=(m*d*i-h*Z*i-m*r*P+n*Z*P+h*r*A-n*d*A)*M,t[2]=(a*Z*i-m*l*i+m*r*c-n*Z*c-a*r*A+n*l*A)*M,t[3]=(h*l*i-a*d*i-h*r*c+n*d*c+a*r*P-n*l*P)*M,t[4]=X*M,t[5]=(u*Z*i-p*d*i+p*r*P-e*Z*P-u*r*A+e*d*A)*M,t[6]=(p*l*i-o*Z*i-p*r*c+e*Z*c+o*r*A-e*l*A)*M,t[7]=(o*d*i-u*l*i+u*r*c-e*d*c-o*r*P+e*l*P)*M,t[8]=Y*M,t[9]=(p*h*i-u*m*i-p*n*P+e*m*P+u*n*A-e*h*A)*M,t[10]=(o*m*i-p*a*i+p*n*c-e*m*c-o*n*A+e*a*A)*M,t[11]=(u*a*i-o*h*i-u*n*c+e*h*c+o*n*P-e*a*P)*M,t[12]=f*M,t[13]=(u*m*r-p*h*r+p*n*d-e*m*d-u*n*Z+e*h*Z)*M,t[14]=(p*a*r-o*m*r-p*n*l+e*m*l+o*n*Z-e*a*Z)*M,t[15]=(o*h*r-u*a*r+u*n*l-e*h*l-o*n*d+e*a*d)*M,new s(t)}toString(){const[t,e,n,r,i,o,s,a,l,c,u,h,d,P,p,m]=this.m;return`R0=(${t}, ${i}, ${l}, ${d}), R1=(${e}, ${o}, ${c}, ${P}), R2=(${n}, ${s}, ${u}, ${p}), R3=(${r}, ${a}, ${h}, ${m})`}}e.Transform=s},226:(t,e,n)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Vector3d=void 0;const r=n(582),i=n(653),o=n(561),s=n(614),a=n(35),l=n(950);class c{constructor(t,e,n){this.X=t,this.Y=e,this.Z=n}static CreateFromVector(t){return new c(t.X,t.Y,t.Z)}static CreateFromPoint3d(t){return new c(t.X,t.Y,t.Z)}get IsUnitVector(){return o.Open3dMath.EpsilonEquals(this.Length,1)}get IsZero(){return o.Open3dMath.EpsilonEquals(this.X,0)&&o.Open3dMath.EpsilonEquals(this.Y,0)&&o.Open3dMath.EpsilonEquals(this.Z,0)}get Length(){return Math.hypot(this.X,this.Y,this.Z)}static Add(t,e){return new c(t.X+e.X,t.Y+e.Y,t.Z+e.Z)}static AddToPoint(t,e){return new a.Point3d(t.X+e.X,t.Y+e.Y,t.Z+e.Z)}Add(t){return c.Add(this,t)}AddToPoint(t){return c.AddToPoint(this,t)}static Subtract(t,e){return new c(t.X-e.X,t.Y-e.Y,t.Z-e.Z)}Subtract(t){return c.Subtract(this,t)}static Multiply(t,e){return new c(t.X*e,t.Y*e,t.Z*e)}Multiply(t){return c.Multiply(this,t)}static Divide(t,e){if(0===e)throw new Error("Division by zero");const n=1/e;return new c(t.X*n,t.Y*n,t.Z*n)}Divide(t){return c.Divide(this,t)}static Interpolate(t,e,n){return new c(t.X+(e.X-t.X)*n,t.Y+(e.Y-t.Y)*n,t.Z+(e.Z-t.Z)*n)}static DotProduct(t,e){return t.X*e.X+t.Y*e.Y+t.Z*e.Z}DotProduct(t){return c.DotProduct(this,t)}static CrossProduct(t,e){return new c(t.Y*e.Z-e.Y*t.Z,t.Z*e.X-e.Z*t.X,t.X*e.Y-e.X*t.Y)}CrossProduct(t){return c.CrossProduct(this,t)}static Distance(t,e){return e.Subtract(t).Length}DistanceTo(t){return c.Distance(this,t)}static Equals(t,e){return o.Open3dMath.EpsilonEquals(t.X,e.X)&&o.Open3dMath.EpsilonEquals(t.Y,e.Y)&&o.Open3dMath.EpsilonEquals(t.Z,e.Z)}Equals(t){return c.Equals(this,t)}static VectorAngle(t,e){if(t.IsZero||e.IsZero)throw new Error("Cannot compute angle of zero-length vector.");let n=c.DotProduct(t,e)/(t.Length*e.Length);return n=o.Open3dMath.Clamp(n,-1,1),Math.acos(n)}static VectorAngle2D(t,e){if(t.IsZero||e.IsZero)throw new Error("Cannot compute angle of zero-length vector.");if(t=new c(t.X,t.Y,0),e=new c(e.X,e.Y,0),t.IsZero||e.IsZero)throw new Error("After projecting vectors zero-length vectors were created, no angle can be calculated.");const n=c.VectorAngle(t,e);return c.CrossProduct(t,e).Z<0?2*Math.PI-n:n}VectorAngle(t){return c.VectorAngle(this,t)}static Reverse(t){return new c(-t.X,-t.Y,-t.Z)}Reverse(){return c.Reverse(this)}static Unitize(t){var e=t.Length;if(0===e)throw new Error("Cannot unitize a zero-length vector.");return new c((Math.abs(t.X)<this.UNITIZE_TOLERANCE/e?0:t.X)/e,(Math.abs(t.Y)<this.UNITIZE_TOLERANCE/e?0:t.Y)/e,(Math.abs(t.Z)<this.UNITIZE_TOLERANCE/e?0:t.Z)/e)}Unitize(){return c.Unitize(this)}static IsParallel(t,e){if(t.IsZero||e.IsZero)return i.Open3d.ParallelIndicator.Parallel;const n=c.VectorAngle(t,e);return o.Open3dMath.EpsilonEquals(n,0,i.Open3d.ANGLE_EPSILON)?i.Open3d.ParallelIndicator.Parallel:o.Open3dMath.EpsilonEquals(n,Math.PI,i.Open3d.ANGLE_EPSILON)?i.Open3d.ParallelIndicator.AntiParallel:i.Open3d.ParallelIndicator.NotParallel}IsParallelTo(t){return t instanceof r.Line?c.IsParallel(this,t.Direction):t instanceof s.Plane?c.IsPerpendicular(this,t.Normal)?i.Open3d.ParallelIndicator.Parallel:i.Open3d.ParallelIndicator.NotParallel:c.IsParallel(this,t)}static IsPerpendicular(t,e){if(t.IsZero||e.IsZero)return!0;const n=c.VectorAngle(t,e);return!!o.Open3dMath.EpsilonEquals(n,Math.PI/2,i.Open3d.ANGLE_EPSILON)||!!o.Open3dMath.EpsilonEquals(n,-Math.PI/2,i.Open3d.ANGLE_EPSILON)}IsPerpendicularTo(t){return c.IsPerpendicular(this,t)}VectorRotate(t,e){const n=l.Transform.RotateAtOrigin(t,e);return this.Transform(n)}GetPerpendicularVector(){let t,e,n,r,i;n=2,Math.abs(this.Y)>Math.abs(this.X)?Math.abs(this.Z)>Math.abs(this.Y)?(t=2,e=1,n=0,r=this.Z,i=-this.Y):Math.abs(this.Z)>=Math.abs(this.X)?(t=1,e=2,n=0,r=this.Y,i=-this.Z):(t=1,e=0,n=2,r=this.Y,i=-this.X):Math.abs(this.Z)>Math.abs(this.X)?(t=2,e=0,n=1,r=this.Z,i=-this.X):Math.abs(this.Z)>Math.abs(this.Y)?(t=0,e=2,n=1,r=this.X,i=-this.Z):(t=0,e=1,n=2,r=this.X,i=-this.Y);let o=[0,0,0];return o[t]=i,o[e]=r,o[n]=0,new c(o[0],o[1],o[2]).Unitize()}Transform(t){let e,n,r;const i=t.M;return i[3]=0,i[7]=0,i[11]=0,e=i[0]*this.X+i[1]*this.Y+i[2]*this.Z+i[3],n=i[4]*this.X+i[5]*this.Y+i[6]*this.Z+i[7],r=i[8]*this.X+i[9]*this.Y+i[10]*this.Z+i[11],new c(e,n,r)}toString(){return`Vector3d [${this.X}, ${this.Y}, ${this.Z}]`}}e.Vector3d=c,c.UNITIZE_TOLERANCE=1e-9,c.XAxis=new c(1,0,0),c.YAxis=new c(0,1,0),c.ZAxis=new c(0,0,1),c.Zero=new c(0,0,0)},323:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.IntersectionEvent=void 0,e.IntersectionEvent=class{constructor(t,e,n,r){this.ParameterA=t,this.ParameterB=e,this.PointA=n,this.PointB=r}}}},e={};function n(r){var i=e[r];if(void 0!==i)return i.exports;var o=e[r]={exports:{}};return t[r](o,o.exports,n),o.exports}var r={};return(()=>{var t=r;Object.defineProperty(t,"__esModule",{value:!0}),t.Open3d=t.Open3dMath=t.Intersection=t.Transform=t.Plane=t.Line=t.Point3d=t.Vector3d=void 0;var e=n(226);Object.defineProperty(t,"Vector3d",{enumerable:!0,get:function(){return e.Vector3d}});var i=n(35);Object.defineProperty(t,"Point3d",{enumerable:!0,get:function(){return i.Point3d}});var o=n(582);Object.defineProperty(t,"Line",{enumerable:!0,get:function(){return o.Line}});var s=n(614);Object.defineProperty(t,"Plane",{enumerable:!0,get:function(){return s.Plane}});var a=n(950);Object.defineProperty(t,"Transform",{enumerable:!0,get:function(){return a.Transform}});var l=n(465);Object.defineProperty(t,"Intersection",{enumerable:!0,get:function(){return l.Intersection}});var c=n(561);Object.defineProperty(t,"Open3dMath",{enumerable:!0,get:function(){return c.Open3dMath}});var u=n(653);Object.defineProperty(t,"Open3d",{enumerable:!0,get:function(){return u.Open3d}})})(),r})()));